# 单点登录设计相关问题 - 前端面试指南

## 📋 常见面试题与答案

### Q1: 什么是单点登录？主要有哪些实现方案？

**标准答案：**
单点登录(SSO)允许用户在一个系统登录后，无需再次登录即可访问其他相关系统。主要方案包括CAS、OAuth2、SAML、JWT等。

**面试回答技巧：**
```javascript
// SSO 核心流程
class SSOService {
  constructor(config) {
    this.authServer = config.authServer;
    this.clientId = config.clientId;
    this.redirectUri = config.redirectUri;
  }

  // 跳转到认证中心
  redirectToLogin() {
    const params = new URLSearchParams({
      client_id: this.clientId,
      redirect_uri: this.redirectUri,
      response_type: 'code',
      scope: 'openid profile'
    });
    
    window.location.href = `${this.authServer}/oauth/authorize?${params}`;
  }

  // 处理认证回调
  async handleCallback(code) {
    const token = await this.exchangeCodeForToken(code);
    this.storeToken(token);
    return token;
  }
}
```

**详细解答：**
1. **CAS协议**：中央认证服务，经典的SSO解决方案
2. **OAuth2.0**：授权框架，支持多种授权模式
3. **SAML**：安全断言标记语言，企业级SSO标准
4. **JWT Token**：轻量级的token方案

### Q2: OAuth2.0的授权码模式具体是如何实现的？

**标准答案：**
授权码模式通过用户代理重定向、授权码交换、令牌验证等步骤实现安全的授权流程。

**面试回答技巧：**
```javascript
// OAuth2 授权码模式实现
class OAuth2Client {
  async authorize() {
    // 1. 跳转到授权服务器
    const authUrl = this.buildAuthUrl();
    window.location.href = authUrl;
  }

  async handleAuthCallback(code, state) {
    // 2. 验证state参数防CSRF
    if (state !== this.getStoredState()) {
      throw new Error('Invalid state parameter');
    }

    // 3. 用授权码交换访问令牌
    const tokenResponse = await fetch('/api/oauth/token', {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: new URLSearchParams({
        grant_type: 'authorization_code',
        code: code,
        client_id: this.clientId,
        client_secret: this.clientSecret,
        redirect_uri: this.redirectUri
      })
    });

    const tokens = await tokenResponse.json();
    this.storeTokens(tokens);
    return tokens;
  }
}
```

**详细解答：**
- **步骤1**：用户访问客户端，重定向到授权服务器
- **步骤2**：用户在授权服务器登录并授权
- **步骤3**：授权服务器重定向回客户端并携带授权码
- **步骤4**：客户端用授权码交换访问令牌

### Q3: 前端如何处理Token的存储和刷新？

**标准答案：**
Token存储需要考虑安全性，通过httpOnly Cookie或安全的localStorage存储，并实现自动刷新机制。

**面试回答技巧：**
```javascript
class TokenManager {
  constructor() {
    this.accessToken = null;
    this.refreshToken = null;
    this.tokenExpiryTime = null;
  }

  // 安全存储token
  storeTokens(tokens) {
    // 访问令牌存储在内存中（安全性高）
    this.accessToken = tokens.access_token;
    this.tokenExpiryTime = Date.now() + tokens.expires_in * 1000;
    
    // 刷新令牌存储在httpOnly cookie中
    document.cookie = `refresh_token=${tokens.refresh_token}; HttpOnly; Secure; SameSite=Strict`;
  }

  // 自动刷新token
  async getValidToken() {
    if (this.isTokenExpired()) {
      await this.refreshAccessToken();
    }
    return this.accessToken;
  }

  async refreshAccessToken() {
    const response = await fetch('/api/auth/refresh', {
      method: 'POST',
      credentials: 'include' // 携带httpOnly cookie
    });
    
    if (response.ok) {
      const tokens = await response.json();
      this.storeTokens(tokens);
    } else {
      this.redirectToLogin();
    }
  }
}
```

**详细解答：**
- **存储方案**：访问令牌在内存，刷新令牌在httpOnly Cookie
- **自动刷新**：在请求拦截器中检查并刷新过期token
- **安全考虑**：避免XSS攻击获取token
- **降级处理**：刷新失败时重新登录

### Q4: 如何实现跨域的单点登录？

**标准答案：**
跨域SSO通过iframe通信、PostMessage、JSONP、代理服务等方式实现不同域名下的身份认证共享。

**面试回答技巧：**
```javascript
// 跨域SSO实现方案
class CrossDomainSSO {
  constructor(ssoServerUrl) {
    this.ssoServerUrl = ssoServerUrl;
    this.iframe = null;
  }

  // 方案1：iframe + postMessage
  async checkSSOStatus() {
    return new Promise((resolve) => {
      // 创建隐藏iframe
      this.iframe = document.createElement('iframe');
      this.iframe.style.display = 'none';
      this.iframe.src = `${this.ssoServerUrl}/check-status`;
      
      // 监听消息
      window.addEventListener('message', (event) => {
        if (event.origin === this.ssoServerUrl && event.data.type === 'sso-status') {
          resolve(event.data.isLoggedIn);
          document.body.removeChild(this.iframe);
        }
      });
      
      document.body.appendChild(this.iframe);
    });
  }

  // 方案2：JSONP检查登录状态
  checkSSOStatusByJSONP() {
    return new Promise((resolve) => {
      const callbackName = 'ssoCallback_' + Date.now();
      window[callbackName] = (data) => {
        resolve(data.isLoggedIn);
        document.head.removeChild(script);
        delete window[callbackName];
      };

      const script = document.createElement('script');
      script.src = `${this.ssoServerUrl}/status?callback=${callbackName}`;
      document.head.appendChild(script);
    });
  }
}
```

**详细解答：**
- **iframe方案**：通过iframe嵌入SSO服务器页面进行通信
- **JSONP方案**：利用script标签跨域特性
- **代理方案**：通过后端代理转发认证请求
- **Cookie共享**：设置domain为父域名实现子域名共享

### Q5: 单点登录如何处理单点退出？

**标准答案：**
单点退出需要通知所有相关系统清除用户会话，通过前端轮询、WebSocket通知、iframe通信等方式实现。

**面试回答技巧：**
```javascript
class SSOLogoutManager {
  constructor() {
    this.logoutNotifiers = new Set();
    this.setupLogoutListener();
  }

  // 方案1：轮询检查登录状态
  startLogoutPolling() {
    this.pollingInterval = setInterval(async () => {
      const isLoggedIn = await this.checkSSOStatus();
      if (!isLoggedIn && this.currentUser) {
        this.handleGlobalLogout();
      }
    }, 30000); // 30秒检查一次
  }

  // 方案2：WebSocket实时通知
  setupWebSocketNotification() {
    const ws = new WebSocket('wss://sso.example.com/logout-notify');
    ws.onmessage = (event) => {
      const data = JSON.parse(event.data);
      if (data.type === 'logout' && data.userId === this.currentUser.id) {
        this.handleGlobalLogout();
      }
    };
  }

  // 处理全局退出
  handleGlobalLogout() {
    // 清除本地token和状态
    this.clearLocalAuth();
    
    // 通知所有注册的组件
    this.logoutNotifiers.forEach(callback => callback());
    
    // 重定向到登录页
    window.location.href = '/login';
  }
}
```

**详细解答：**
- **轮询检查**：定期检查SSO服务器的登录状态
- **推送通知**：通过WebSocket等实时通知机制
- **iframe通信**：在隐藏iframe中监听退出事件
- **本地清理**：清除所有本地存储的认证信息

## 🎯 面试技巧总结

### 回答策略

**1. 协议理解优先**
- 先讲清楚SSO的基本原理和流程
- 重点说明安全性和用户体验的平衡

**2. 实现方案对比**
- 对比不同协议的优缺点和适用场景
- 展示对技术选型的思考能力

**3. 安全性考虑**
- 重点强调token安全存储和传输
- 说明防范CSRF、XSS等攻击的措施

### 加分点

1. **实际项目经验**：有SSO系统的设计或对接经验
2. **安全意识强**：深入理解各种安全风险和防护措施
3. **跨域处理**：熟悉各种跨域SSO的实现方案
4. **性能优化**：考虑大规模用户下的性能问题

### 常见误区

1. **安全性不足**：token存储在localStorage等不安全位置
2. **用户体验差**：频繁的重定向影响用户体验
3. **跨域处理不当**：没有考虑跨域场景的复杂性
4. **退出不彻底**：单点退出没有清理所有相关状态

### 面试准备清单

- [ ] 理解OAuth2.0各种授权模式的区别
- [ ] 掌握JWT的结构和验证方法
- [ ] 了解跨域SSO的各种实现方案
- [ ] 熟悉token的安全存储和刷新机制
- [ ] 准备单点退出的实现方案

## 💡 总结

单点登录系统设计的核心要点：

1. **安全第一**：token安全存储，防范各种攻击
2. **用户体验**：无感知登录，流畅的跳转体验
3. **跨域支持**：支持多域名下的身份认证
4. **性能考虑**：减少不必要的重定向和验证
5. **退出管理**：完整的单点退出机制

面试时要重点展示：
- 对SSO协议的深入理解
- 前端安全意识和实践能力
- 跨域问题的解决经验
- 用户体验和技术实现的平衡考虑 