# å¼‚å¸¸ç›‘æ§ç³»ç»Ÿç›¸å…³é—®é¢˜ - å‰ç«¯é¢è¯•æŒ‡å—

## ğŸ“‹ å¸¸è§é¢è¯•é¢˜ä¸ç­”æ¡ˆ

### Q1: å¦‚ä½•è®¾è®¡å‰ç«¯å¼‚å¸¸ç›‘æ§ç³»ç»Ÿï¼Ÿ

**æ ‡å‡†ç­”æ¡ˆï¼š**
å‰ç«¯å¼‚å¸¸ç›‘æ§ç³»ç»Ÿéœ€è¦æ•è·JavaScripté”™è¯¯ã€ç½‘ç»œé”™è¯¯ã€æ€§èƒ½é—®é¢˜ç­‰ï¼Œå¹¶ä¸ŠæŠ¥åˆ°æœåŠ¡å™¨è¿›è¡Œåˆ†æã€‚

**é¢è¯•å›ç­”æŠ€å·§ï¼š**
```javascript
// å¼‚å¸¸ç›‘æ§ç³»ç»Ÿæ ¸å¿ƒå®ç°
class ErrorMonitor {
  constructor() {
    this.errorQueue = [];
    this.maxQueueSize = 100;
    this.reportUrl = '/api/error-report';
    this.init();
  }

  init() {
    // å…¨å±€é”™è¯¯ç›‘å¬
    window.addEventListener('error', this.handleError.bind(this));
    window.addEventListener('unhandledrejection', this.handlePromiseRejection.bind(this));
    
    // ç½‘ç»œé”™è¯¯ç›‘å¬
    this.monitorNetworkErrors();
    
    // æ€§èƒ½ç›‘æ§
    this.monitorPerformance();
  }

  // å¤„ç†JavaScripté”™è¯¯
  handleError(event) {
    const errorInfo = {
      type: 'js_error',
      message: event.message,
      filename: event.filename,
      lineno: event.lineno,
      colno: event.colno,
      stack: event.error?.stack,
      timestamp: Date.now(),
      userAgent: navigator.userAgent,
      url: window.location.href
    };
    
    this.addToQueue(errorInfo);
  }

  // å¤„ç†Promiseæ‹’ç»
  handlePromiseRejection(event) {
    const errorInfo = {
      type: 'promise_rejection',
      message: event.reason?.message || 'Promise rejected',
      stack: event.reason?.stack,
      timestamp: Date.now(),
      userAgent: navigator.userAgent,
      url: window.location.href
    };
    
    this.addToQueue(errorInfo);
  }

  // ç›‘æ§ç½‘ç»œé”™è¯¯
  monitorNetworkErrors() {
    const originalFetch = window.fetch;
    window.fetch = async (...args) => {
      try {
        const response = await originalFetch(...args);
        if (!response.ok) {
          this.reportNetworkError(response.status, response.statusText, args[0]);
        }
        return response;
      } catch (error) {
        this.reportNetworkError(0, error.message, args[0]);
        throw error;
      }
    };
  }

  // æ€§èƒ½ç›‘æ§
  monitorPerformance() {
    if ('PerformanceObserver' in window) {
      // ç›‘æ§é•¿ä»»åŠ¡
      const longTaskObserver = new PerformanceObserver((list) => {
        list.getEntries().forEach((entry) => {
          if (entry.duration > 50) { // è¶…è¿‡50msçš„ä»»åŠ¡
            this.reportPerformanceIssue('long_task', entry);
          }
        });
      });
      longTaskObserver.observe({ entryTypes: ['longtask'] });

      // ç›‘æ§èµ„æºåŠ è½½
      const resourceObserver = new PerformanceObserver((list) => {
        list.getEntries().forEach((entry) => {
          if (entry.duration > 3000) { // è¶…è¿‡3ç§’çš„èµ„æºåŠ è½½
            this.reportPerformanceIssue('slow_resource', entry);
          }
        });
      });
      resourceObserver.observe({ entryTypes: ['resource'] });
    }
  }

  // æ·»åŠ åˆ°é˜Ÿåˆ—
  addToQueue(errorInfo) {
    this.errorQueue.push(errorInfo);
    
    if (this.errorQueue.length >= this.maxQueueSize) {
      this.flushQueue();
    }
  }

  // ä¸ŠæŠ¥é”™è¯¯
  async reportError(errorInfo) {
    try {
      await fetch(this.reportUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(errorInfo)
      });
    } catch (error) {
      console.error('Error reporting failed:', error);
    }
  }

  // æ‰¹é‡ä¸ŠæŠ¥
  async flushQueue() {
    if (this.errorQueue.length === 0) return;
    
    const errors = [...this.errorQueue];
    this.errorQueue = [];
    
    try {
      await fetch(this.reportUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ errors })
      });
    } catch (error) {
      console.error('Batch error reporting failed:', error);
    }
  }
}
```

### Q2: å¦‚ä½•æ•è·ä¸åŒç±»å‹çš„é”™è¯¯ï¼Ÿ

**æ ‡å‡†ç­”æ¡ˆï¼š**
éœ€è¦æ•è·JavaScriptè¿è¡Œæ—¶é”™è¯¯ã€å¼‚æ­¥é”™è¯¯ã€ç½‘ç»œé”™è¯¯ã€èµ„æºåŠ è½½é”™è¯¯ç­‰ã€‚

**é¢è¯•å›ç­”æŠ€å·§ï¼š**
```javascript
// é”™è¯¯æ•è·å™¨
class ErrorCatcher {
  constructor() {
    this.errorTypes = {
      RUNTIME: 'runtime_error',
      SYNTAX: 'syntax_error',
      ASYNC: 'async_error',
      NETWORK: 'network_error',
      RESOURCE: 'resource_error'
    };
  }

  // æ•è·è¿è¡Œæ—¶é”™è¯¯
  catchRuntimeError() {
    window.addEventListener('error', (event) => {
      const errorInfo = {
        type: this.errorTypes.RUNTIME,
        message: event.message,
        filename: event.filename,
        lineno: event.lineno,
        colno: event.colno,
        stack: event.error?.stack,
        timestamp: Date.now()
      };
      
      this.reportError(errorInfo);
    });
  }

  // æ•è·å¼‚æ­¥é”™è¯¯
  catchAsyncError() {
    window.addEventListener('unhandledrejection', (event) => {
      const errorInfo = {
        type: this.errorTypes.ASYNC,
        message: event.reason?.message || 'Promise rejected',
        stack: event.reason?.stack,
        timestamp: Date.now()
      };
      
      this.reportError(errorInfo);
    });
  }

  // æ•è·ç½‘ç»œé”™è¯¯
  catchNetworkError() {
    // æ‹¦æˆªfetchè¯·æ±‚
    const originalFetch = window.fetch;
    window.fetch = async (...args) => {
      try {
        const response = await originalFetch(...args);
        if (!response.ok) {
          this.reportError({
            type: this.errorTypes.NETWORK,
            status: response.status,
            statusText: response.statusText,
            url: args[0],
            timestamp: Date.now()
          });
        }
        return response;
      } catch (error) {
        this.reportError({
          type: this.errorTypes.NETWORK,
          message: error.message,
          url: args[0],
          timestamp: Date.now()
        });
        throw error;
      }
    };
  }

  // æ•è·èµ„æºåŠ è½½é”™è¯¯
  catchResourceError() {
    window.addEventListener('error', (event) => {
      if (event.target && event.target !== window) {
        const errorInfo = {
          type: this.errorTypes.RESOURCE,
          tagName: event.target.tagName,
          src: event.target.src || event.target.href,
          timestamp: Date.now()
        };
        
        this.reportError(errorInfo);
      }
    }, true);
  }

  // é”™è¯¯ä¸ŠæŠ¥
  reportError(errorInfo) {
    // å‘é€åˆ°ç›‘æ§æœåŠ¡å™¨
    console.log('Error reported:', errorInfo);
  }
}
```

### Q3: å¦‚ä½•å®ç°æ€§èƒ½ç›‘æ§ï¼Ÿ

**æ ‡å‡†ç­”æ¡ˆï¼š**
ä½¿ç”¨Performance APIç›‘æ§é¡µé¢åŠ è½½æ€§èƒ½ã€èµ„æºåŠ è½½æ€§èƒ½ã€ç”¨æˆ·äº¤äº’æ€§èƒ½ç­‰ã€‚

**é¢è¯•å›ç­”æŠ€å·§ï¼š**
```javascript
// æ€§èƒ½ç›‘æ§å™¨
class PerformanceMonitor {
  constructor() {
    this.metrics = {};
    this.init();
  }

  init() {
    this.monitorPageLoad();
    this.monitorUserInteractions();
    this.monitorResourceLoading();
    this.monitorLongTasks();
  }

  // ç›‘æ§é¡µé¢åŠ è½½æ€§èƒ½
  monitorPageLoad() {
    window.addEventListener('load', () => {
      const navigation = performance.getEntriesByType('navigation')[0];
      const paint = performance.getEntriesByType('paint');
      
      this.metrics.pageLoad = {
        dnsTime: navigation.domainLookupEnd - navigation.domainLookupStart,
        tcpTime: navigation.connectEnd - navigation.connectStart,
        requestTime: navigation.responseEnd - navigation.requestStart,
        domContentLoaded: navigation.domContentLoadedEventEnd - navigation.domContentLoadedEventStart,
        loadComplete: navigation.loadEventEnd - navigation.loadEventStart,
        firstPaint: paint.find(p => p.name === 'first-paint')?.startTime,
        firstContentfulPaint: paint.find(p => p.name === 'first-contentful-paint')?.startTime
      };
      
      this.reportMetrics('page_load', this.metrics.pageLoad);
    });
  }

  // ç›‘æ§ç”¨æˆ·äº¤äº’æ€§èƒ½
  monitorUserInteractions() {
    let interactionCount = 0;
    
    document.addEventListener('click', (event) => {
      const startTime = performance.now();
      
      // æ¨¡æ‹Ÿäº¤äº’å¤„ç†
      setTimeout(() => {
        const duration = performance.now() - startTime;
        
        if (duration > 100) { // è¶…è¿‡100msçš„äº¤äº’
          this.reportMetrics('slow_interaction', {
            type: 'click',
            duration,
            target: event.target.tagName,
            timestamp: Date.now()
          });
        }
      }, 0);
    });
  }

  // ç›‘æ§èµ„æºåŠ è½½æ€§èƒ½
  monitorResourceLoading() {
    const resourceObserver = new PerformanceObserver((list) => {
      list.getEntries().forEach((entry) => {
        if (entry.duration > 3000) { // è¶…è¿‡3ç§’çš„èµ„æº
          this.reportMetrics('slow_resource', {
            name: entry.name,
            duration: entry.duration,
            size: entry.transferSize,
            timestamp: Date.now()
          });
        }
      });
    });
    
    resourceObserver.observe({ entryTypes: ['resource'] });
  }

  // ç›‘æ§é•¿ä»»åŠ¡
  monitorLongTasks() {
    const longTaskObserver = new PerformanceObserver((list) => {
      list.getEntries().forEach((entry) => {
        if (entry.duration > 50) { // è¶…è¿‡50msçš„ä»»åŠ¡
          this.reportMetrics('long_task', {
            duration: entry.duration,
            startTime: entry.startTime,
            timestamp: Date.now()
          });
        }
      });
    });
    
    longTaskObserver.observe({ entryTypes: ['longtask'] });
  }

  // ä¸ŠæŠ¥æ€§èƒ½æŒ‡æ ‡
  reportMetrics(type, data) {
    const metrics = {
      type,
      data,
      timestamp: Date.now(),
      userAgent: navigator.userAgent,
      url: window.location.href
    };
    
    // å‘é€åˆ°ç›‘æ§æœåŠ¡å™¨
    console.log('Performance metrics:', metrics);
  }
}
```

### Q4: å¦‚ä½•å®ç°é”™è¯¯åˆ†ç±»å’Œèšåˆï¼Ÿ

**æ ‡å‡†ç­”æ¡ˆï¼š**
æ ¹æ®é”™è¯¯ç±»å‹ã€é”™è¯¯ä¿¡æ¯ã€å †æ ˆä¿¡æ¯ç­‰è¿›è¡Œåˆ†ç±»å’Œèšåˆï¼Œå‡å°‘é‡å¤ä¸ŠæŠ¥ã€‚

**é¢è¯•å›ç­”æŠ€å·§ï¼š**
```javascript
// é”™è¯¯åˆ†ç±»å’Œèšåˆå™¨
class ErrorAggregator {
  constructor() {
    this.errorGroups = new Map();
    this.groupTimeout = 60000; // 1åˆ†é’Ÿå†…çš„ç›¸åŒé”™è¯¯èšåˆ
  }

  // é”™è¯¯åˆ†ç±»
  categorizeError(error) {
    const category = this.getErrorCategory(error);
    const fingerprint = this.generateFingerprint(error);
    
    return {
      category,
      fingerprint,
      count: 1,
      firstOccurrence: Date.now(),
      lastOccurrence: Date.now(),
      samples: [error]
    };
  }

  // è·å–é”™è¯¯åˆ†ç±»
  getErrorCategory(error) {
    if (error.type === 'js_error') {
      if (error.message.includes('Cannot read property')) {
        return 'null_pointer';
      } else if (error.message.includes('Unexpected token')) {
        return 'syntax_error';
      } else if (error.message.includes('NetworkError')) {
        return 'network_error';
      }
    }
    
    return 'unknown';
  }

  // ç”Ÿæˆé”™è¯¯æŒ‡çº¹
  generateFingerprint(error) {
    const key = `${error.type}:${error.message}:${error.filename}:${error.lineno}`;
    return this.hashString(key);
  }

  // å­—ç¬¦ä¸²å“ˆå¸Œ
  hashString(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // è½¬æ¢ä¸º32ä½æ•´æ•°
    }
    return hash.toString();
  }

  // èšåˆé”™è¯¯
  aggregateError(error) {
    const fingerprint = this.generateFingerprint(error);
    
    if (this.errorGroups.has(fingerprint)) {
      const group = this.errorGroups.get(fingerprint);
      group.count++;
      group.lastOccurrence = Date.now();
      group.samples.push(error);
      
      // åªä¿ç•™æœ€è¿‘çš„5ä¸ªæ ·æœ¬
      if (group.samples.length > 5) {
        group.samples = group.samples.slice(-5);
      }
    } else {
      this.errorGroups.set(fingerprint, this.categorizeError(error));
    }
  }

  // è·å–èšåˆæŠ¥å‘Š
  getAggregatedReport() {
    const report = [];
    
    for (const [fingerprint, group] of this.errorGroups) {
      report.push({
        fingerprint,
        category: group.category,
        count: group.count,
        firstOccurrence: group.firstOccurrence,
        lastOccurrence: group.lastOccurrence,
        samples: group.samples
      });
    }
    
    return report;
  }
}
```

### Q5: å¦‚ä½•å®ç°å®æ—¶å‘Šè­¦ï¼Ÿ

**æ ‡å‡†ç­”æ¡ˆï¼š**
è®¾ç½®é”™è¯¯é˜ˆå€¼ï¼Œå½“é”™è¯¯ç‡è¶…è¿‡é˜ˆå€¼æ—¶å‘é€å‘Šè­¦é€šçŸ¥ã€‚

**é¢è¯•å›ç­”æŠ€å·§ï¼š**
```javascript
// å®æ—¶å‘Šè­¦ç³»ç»Ÿ
class AlertSystem {
  constructor() {
    this.thresholds = {
      errorRate: 0.05, // 5%é”™è¯¯ç‡
      slowResponse: 3000, // 3ç§’å“åº”æ—¶é—´
      memoryUsage: 0.8 // 80%å†…å­˜ä½¿ç”¨ç‡
    };
    
    this.metrics = {
      totalRequests: 0,
      totalErrors: 0,
      slowRequests: 0
    };
    
    this.init();
  }

  init() {
    // å®šæœŸæ£€æŸ¥æŒ‡æ ‡
    setInterval(() => {
      this.checkMetrics();
    }, 60000); // æ¯åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡
  }

  // è®°å½•è¯·æ±‚
  recordRequest(isError = false, duration = 0) {
    this.metrics.totalRequests++;
    
    if (isError) {
      this.metrics.totalErrors++;
    }
    
    if (duration > this.thresholds.slowResponse) {
      this.metrics.slowRequests++;
    }
  }

  // æ£€æŸ¥æŒ‡æ ‡
  checkMetrics() {
    const errorRate = this.metrics.totalErrors / this.metrics.totalRequests;
    const slowRate = this.metrics.slowRequests / this.metrics.totalRequests;
    
    // æ£€æŸ¥é”™è¯¯ç‡
    if (errorRate > this.thresholds.errorRate) {
      this.sendAlert('high_error_rate', {
        current: errorRate,
        threshold: this.thresholds.errorRate
      });
    }
    
    // æ£€æŸ¥æ…¢è¯·æ±‚ç‡
    if (slowRate > 0.1) { // 10%æ…¢è¯·æ±‚
      this.sendAlert('high_slow_request_rate', {
        current: slowRate,
        threshold: 0.1
      });
    }
    
    // æ£€æŸ¥å†…å­˜ä½¿ç”¨ç‡
    if ('memory' in performance) {
      const memoryUsage = performance.memory.usedJSHeapSize / performance.memory.jsHeapSizeLimit;
      if (memoryUsage > this.thresholds.memoryUsage) {
        this.sendAlert('high_memory_usage', {
          current: memoryUsage,
          threshold: this.thresholds.memoryUsage
        });
      }
    }
  }

  // å‘é€å‘Šè­¦
  sendAlert(type, data) {
    const alert = {
      type,
      data,
      timestamp: Date.now(),
      url: window.location.href,
      userAgent: navigator.userAgent
    };
    
    // å‘é€åˆ°å‘Šè­¦ç³»ç»Ÿ
    console.log('Alert sent:', alert);
    
    // å¯ä»¥é›†æˆé’‰é’‰ã€ä¼ä¸šå¾®ä¿¡ç­‰é€šçŸ¥
    this.sendNotification(alert);
  }

  // å‘é€é€šçŸ¥
  sendNotification(alert) {
    // ç¤ºä¾‹ï¼šå‘é€åˆ°é’‰é’‰
    fetch('/api/alert', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(alert)
    });
  }
}
```

## ğŸ¯ é¢è¯•æŠ€å·§æ€»ç»“

### å›ç­”ç­–ç•¥

**1. ç³»ç»Ÿè®¾è®¡**
- ç†è§£ç›‘æ§ç³»ç»Ÿçš„æ•´ä½“æ¶æ„
- è¯´æ˜å„ä¸ªæ¨¡å—çš„èŒè´£å’Œä½œç”¨

**2. æŠ€æœ¯å®ç°**
- å±•ç¤ºå®é™…çš„ä»£ç å®ç°
- è¯´æ˜é”™è¯¯æ•è·å’Œä¸ŠæŠ¥æœºåˆ¶

**3. æ€§èƒ½è€ƒè™‘**
- ç†è§£ç›‘æ§ç³»ç»Ÿå¯¹æ€§èƒ½çš„å½±å“
- æŒæ¡ä¼˜åŒ–ç­–ç•¥

### åŠ åˆ†ç‚¹

1. **å…¨é¢æ€§**ï¼šå±•ç¤ºå®Œæ•´çš„ç›‘æ§ä½“ç³»
2. **å®æ—¶æ€§**ï¼šå¼ºè°ƒå®æ—¶å‘Šè­¦å’Œå“åº”
3. **å¯æ‰©å±•æ€§**ï¼šè¯´æ˜ç³»ç»Ÿçš„æ‰©å±•èƒ½åŠ›
4. **å®ç”¨æ€§**ï¼šåˆ†äº«å®é™…çš„åº”ç”¨æ¡ˆä¾‹

### å¸¸è§è¯¯åŒº

1. **åªå…³æ³¨é”™è¯¯æ•è·**ï¼šè¦ç†è§£å®Œæ•´çš„ç›‘æ§ä½“ç³»
2. **å¿½è§†æ€§èƒ½å½±å“**ï¼šè¦æ³¨æ„ç›‘æ§ç³»ç»Ÿçš„æ€§èƒ½å¼€é”€
3. **ç¼ºä¹å‘Šè­¦æœºåˆ¶**ï¼šè¦é‡è§†å®æ—¶å‘Šè­¦çš„é‡è¦æ€§
4. **æ²¡æœ‰æ•°æ®åˆ†æ**ï¼šè¦å…³æ³¨æ•°æ®çš„åˆ†æå’Œåˆ©ç”¨

### é¢è¯•å‡†å¤‡æ¸…å•

- [ ] ç†è§£å¼‚å¸¸ç›‘æ§ç³»ç»Ÿçš„æ¶æ„
- [ ] æŒæ¡é”™è¯¯æ•è·å’Œä¸ŠæŠ¥æœºåˆ¶
- [ ] äº†è§£æ€§èƒ½ç›‘æ§æ–¹æ³•
- [ ] æŒæ¡é”™è¯¯åˆ†ç±»å’Œèšåˆ
- [ ] äº†è§£å®æ—¶å‘Šè­¦æœºåˆ¶
- [ ] å‡†å¤‡å®é™…é¡¹ç›®æ¡ˆä¾‹

## ğŸ’¡ æ€»ç»“

å¼‚å¸¸ç›‘æ§ç³»ç»Ÿåœ¨å‰ç«¯å¼€å‘ä¸­ä¸»è¦ç”¨äºï¼š
1. **é”™è¯¯è¿½è¸ª**ï¼šåŠæ—¶å‘ç°å’Œå®šä½é—®é¢˜
2. **æ€§èƒ½ç›‘æ§**ï¼šç›‘æ§åº”ç”¨æ€§èƒ½æŒ‡æ ‡
3. **ç”¨æˆ·ä½“éªŒ**ï¼šæå‡åº”ç”¨ç¨³å®šæ€§
4. **æ•°æ®åˆ†æ**ï¼šä¸ºä¼˜åŒ–æä¾›æ•°æ®æ”¯æŒ

é¢è¯•æ—¶è¦é‡ç‚¹å±•ç¤ºï¼š
- å¯¹ç›‘æ§ç³»ç»Ÿæ¶æ„çš„ç†è§£
- å®é™…çš„ä»£ç å®ç°ç»éªŒ
- æ€§èƒ½ä¼˜åŒ–å’Œå‘Šè­¦æœºåˆ¶
- æ•°æ®åˆ†æå’Œåˆ©ç”¨èƒ½åŠ› 