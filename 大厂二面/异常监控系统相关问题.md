# 异常监控系统相关问题 - 前端面试指南

## 📋 常见面试题与答案

### Q1: 如何设计前端异常监控系统？

**标准答案：**
前端异常监控系统需要捕获JavaScript错误、网络错误、性能问题等，并上报到服务器进行分析。

**面试回答技巧：**
```javascript
// 异常监控系统核心实现
class ErrorMonitor {
  constructor() {
    this.errorQueue = [];
    this.maxQueueSize = 100;
    this.reportUrl = '/api/error-report';
    this.init();
  }

  init() {
    // 全局错误监听
    window.addEventListener('error', this.handleError.bind(this));
    window.addEventListener('unhandledrejection', this.handlePromiseRejection.bind(this));
    
    // 网络错误监听
    this.monitorNetworkErrors();
    
    // 性能监控
    this.monitorPerformance();
  }

  // 处理JavaScript错误
  handleError(event) {
    const errorInfo = {
      type: 'js_error',
      message: event.message,
      filename: event.filename,
      lineno: event.lineno,
      colno: event.colno,
      stack: event.error?.stack,
      timestamp: Date.now(),
      userAgent: navigator.userAgent,
      url: window.location.href
    };
    
    this.addToQueue(errorInfo);
  }

  // 处理Promise拒绝
  handlePromiseRejection(event) {
    const errorInfo = {
      type: 'promise_rejection',
      message: event.reason?.message || 'Promise rejected',
      stack: event.reason?.stack,
      timestamp: Date.now(),
      userAgent: navigator.userAgent,
      url: window.location.href
    };
    
    this.addToQueue(errorInfo);
  }

  // 监控网络错误
  monitorNetworkErrors() {
    const originalFetch = window.fetch;
    window.fetch = async (...args) => {
      try {
        const response = await originalFetch(...args);
        if (!response.ok) {
          this.reportNetworkError(response.status, response.statusText, args[0]);
        }
        return response;
      } catch (error) {
        this.reportNetworkError(0, error.message, args[0]);
        throw error;
      }
    };
  }

  // 性能监控
  monitorPerformance() {
    if ('PerformanceObserver' in window) {
      // 监控长任务
      const longTaskObserver = new PerformanceObserver((list) => {
        list.getEntries().forEach((entry) => {
          if (entry.duration > 50) { // 超过50ms的任务
            this.reportPerformanceIssue('long_task', entry);
          }
        });
      });
      longTaskObserver.observe({ entryTypes: ['longtask'] });

      // 监控资源加载
      const resourceObserver = new PerformanceObserver((list) => {
        list.getEntries().forEach((entry) => {
          if (entry.duration > 3000) { // 超过3秒的资源加载
            this.reportPerformanceIssue('slow_resource', entry);
          }
        });
      });
      resourceObserver.observe({ entryTypes: ['resource'] });
    }
  }

  // 添加到队列
  addToQueue(errorInfo) {
    this.errorQueue.push(errorInfo);
    
    if (this.errorQueue.length >= this.maxQueueSize) {
      this.flushQueue();
    }
  }

  // 上报错误
  async reportError(errorInfo) {
    try {
      await fetch(this.reportUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(errorInfo)
      });
    } catch (error) {
      console.error('Error reporting failed:', error);
    }
  }

  // 批量上报
  async flushQueue() {
    if (this.errorQueue.length === 0) return;
    
    const errors = [...this.errorQueue];
    this.errorQueue = [];
    
    try {
      await fetch(this.reportUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ errors })
      });
    } catch (error) {
      console.error('Batch error reporting failed:', error);
    }
  }
}
```

### Q2: 如何捕获不同类型的错误？

**标准答案：**
需要捕获JavaScript运行时错误、异步错误、网络错误、资源加载错误等。

**面试回答技巧：**
```javascript
// 错误捕获器
class ErrorCatcher {
  constructor() {
    this.errorTypes = {
      RUNTIME: 'runtime_error',
      SYNTAX: 'syntax_error',
      ASYNC: 'async_error',
      NETWORK: 'network_error',
      RESOURCE: 'resource_error'
    };
  }

  // 捕获运行时错误
  catchRuntimeError() {
    window.addEventListener('error', (event) => {
      const errorInfo = {
        type: this.errorTypes.RUNTIME,
        message: event.message,
        filename: event.filename,
        lineno: event.lineno,
        colno: event.colno,
        stack: event.error?.stack,
        timestamp: Date.now()
      };
      
      this.reportError(errorInfo);
    });
  }

  // 捕获异步错误
  catchAsyncError() {
    window.addEventListener('unhandledrejection', (event) => {
      const errorInfo = {
        type: this.errorTypes.ASYNC,
        message: event.reason?.message || 'Promise rejected',
        stack: event.reason?.stack,
        timestamp: Date.now()
      };
      
      this.reportError(errorInfo);
    });
  }

  // 捕获网络错误
  catchNetworkError() {
    // 拦截fetch请求
    const originalFetch = window.fetch;
    window.fetch = async (...args) => {
      try {
        const response = await originalFetch(...args);
        if (!response.ok) {
          this.reportError({
            type: this.errorTypes.NETWORK,
            status: response.status,
            statusText: response.statusText,
            url: args[0],
            timestamp: Date.now()
          });
        }
        return response;
      } catch (error) {
        this.reportError({
          type: this.errorTypes.NETWORK,
          message: error.message,
          url: args[0],
          timestamp: Date.now()
        });
        throw error;
      }
    };
  }

  // 捕获资源加载错误
  catchResourceError() {
    window.addEventListener('error', (event) => {
      if (event.target && event.target !== window) {
        const errorInfo = {
          type: this.errorTypes.RESOURCE,
          tagName: event.target.tagName,
          src: event.target.src || event.target.href,
          timestamp: Date.now()
        };
        
        this.reportError(errorInfo);
      }
    }, true);
  }

  // 错误上报
  reportError(errorInfo) {
    // 发送到监控服务器
    console.log('Error reported:', errorInfo);
  }
}
```

### Q3: 如何实现性能监控？

**标准答案：**
使用Performance API监控页面加载性能、资源加载性能、用户交互性能等。

**面试回答技巧：**
```javascript
// 性能监控器
class PerformanceMonitor {
  constructor() {
    this.metrics = {};
    this.init();
  }

  init() {
    this.monitorPageLoad();
    this.monitorUserInteractions();
    this.monitorResourceLoading();
    this.monitorLongTasks();
  }

  // 监控页面加载性能
  monitorPageLoad() {
    window.addEventListener('load', () => {
      const navigation = performance.getEntriesByType('navigation')[0];
      const paint = performance.getEntriesByType('paint');
      
      this.metrics.pageLoad = {
        dnsTime: navigation.domainLookupEnd - navigation.domainLookupStart,
        tcpTime: navigation.connectEnd - navigation.connectStart,
        requestTime: navigation.responseEnd - navigation.requestStart,
        domContentLoaded: navigation.domContentLoadedEventEnd - navigation.domContentLoadedEventStart,
        loadComplete: navigation.loadEventEnd - navigation.loadEventStart,
        firstPaint: paint.find(p => p.name === 'first-paint')?.startTime,
        firstContentfulPaint: paint.find(p => p.name === 'first-contentful-paint')?.startTime
      };
      
      this.reportMetrics('page_load', this.metrics.pageLoad);
    });
  }

  // 监控用户交互性能
  monitorUserInteractions() {
    let interactionCount = 0;
    
    document.addEventListener('click', (event) => {
      const startTime = performance.now();
      
      // 模拟交互处理
      setTimeout(() => {
        const duration = performance.now() - startTime;
        
        if (duration > 100) { // 超过100ms的交互
          this.reportMetrics('slow_interaction', {
            type: 'click',
            duration,
            target: event.target.tagName,
            timestamp: Date.now()
          });
        }
      }, 0);
    });
  }

  // 监控资源加载性能
  monitorResourceLoading() {
    const resourceObserver = new PerformanceObserver((list) => {
      list.getEntries().forEach((entry) => {
        if (entry.duration > 3000) { // 超过3秒的资源
          this.reportMetrics('slow_resource', {
            name: entry.name,
            duration: entry.duration,
            size: entry.transferSize,
            timestamp: Date.now()
          });
        }
      });
    });
    
    resourceObserver.observe({ entryTypes: ['resource'] });
  }

  // 监控长任务
  monitorLongTasks() {
    const longTaskObserver = new PerformanceObserver((list) => {
      list.getEntries().forEach((entry) => {
        if (entry.duration > 50) { // 超过50ms的任务
          this.reportMetrics('long_task', {
            duration: entry.duration,
            startTime: entry.startTime,
            timestamp: Date.now()
          });
        }
      });
    });
    
    longTaskObserver.observe({ entryTypes: ['longtask'] });
  }

  // 上报性能指标
  reportMetrics(type, data) {
    const metrics = {
      type,
      data,
      timestamp: Date.now(),
      userAgent: navigator.userAgent,
      url: window.location.href
    };
    
    // 发送到监控服务器
    console.log('Performance metrics:', metrics);
  }
}
```

### Q4: 如何实现错误分类和聚合？

**标准答案：**
根据错误类型、错误信息、堆栈信息等进行分类和聚合，减少重复上报。

**面试回答技巧：**
```javascript
// 错误分类和聚合器
class ErrorAggregator {
  constructor() {
    this.errorGroups = new Map();
    this.groupTimeout = 60000; // 1分钟内的相同错误聚合
  }

  // 错误分类
  categorizeError(error) {
    const category = this.getErrorCategory(error);
    const fingerprint = this.generateFingerprint(error);
    
    return {
      category,
      fingerprint,
      count: 1,
      firstOccurrence: Date.now(),
      lastOccurrence: Date.now(),
      samples: [error]
    };
  }

  // 获取错误分类
  getErrorCategory(error) {
    if (error.type === 'js_error') {
      if (error.message.includes('Cannot read property')) {
        return 'null_pointer';
      } else if (error.message.includes('Unexpected token')) {
        return 'syntax_error';
      } else if (error.message.includes('NetworkError')) {
        return 'network_error';
      }
    }
    
    return 'unknown';
  }

  // 生成错误指纹
  generateFingerprint(error) {
    const key = `${error.type}:${error.message}:${error.filename}:${error.lineno}`;
    return this.hashString(key);
  }

  // 字符串哈希
  hashString(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // 转换为32位整数
    }
    return hash.toString();
  }

  // 聚合错误
  aggregateError(error) {
    const fingerprint = this.generateFingerprint(error);
    
    if (this.errorGroups.has(fingerprint)) {
      const group = this.errorGroups.get(fingerprint);
      group.count++;
      group.lastOccurrence = Date.now();
      group.samples.push(error);
      
      // 只保留最近的5个样本
      if (group.samples.length > 5) {
        group.samples = group.samples.slice(-5);
      }
    } else {
      this.errorGroups.set(fingerprint, this.categorizeError(error));
    }
  }

  // 获取聚合报告
  getAggregatedReport() {
    const report = [];
    
    for (const [fingerprint, group] of this.errorGroups) {
      report.push({
        fingerprint,
        category: group.category,
        count: group.count,
        firstOccurrence: group.firstOccurrence,
        lastOccurrence: group.lastOccurrence,
        samples: group.samples
      });
    }
    
    return report;
  }
}
```

### Q5: 如何实现实时告警？

**标准答案：**
设置错误阈值，当错误率超过阈值时发送告警通知。

**面试回答技巧：**
```javascript
// 实时告警系统
class AlertSystem {
  constructor() {
    this.thresholds = {
      errorRate: 0.05, // 5%错误率
      slowResponse: 3000, // 3秒响应时间
      memoryUsage: 0.8 // 80%内存使用率
    };
    
    this.metrics = {
      totalRequests: 0,
      totalErrors: 0,
      slowRequests: 0
    };
    
    this.init();
  }

  init() {
    // 定期检查指标
    setInterval(() => {
      this.checkMetrics();
    }, 60000); // 每分钟检查一次
  }

  // 记录请求
  recordRequest(isError = false, duration = 0) {
    this.metrics.totalRequests++;
    
    if (isError) {
      this.metrics.totalErrors++;
    }
    
    if (duration > this.thresholds.slowResponse) {
      this.metrics.slowRequests++;
    }
  }

  // 检查指标
  checkMetrics() {
    const errorRate = this.metrics.totalErrors / this.metrics.totalRequests;
    const slowRate = this.metrics.slowRequests / this.metrics.totalRequests;
    
    // 检查错误率
    if (errorRate > this.thresholds.errorRate) {
      this.sendAlert('high_error_rate', {
        current: errorRate,
        threshold: this.thresholds.errorRate
      });
    }
    
    // 检查慢请求率
    if (slowRate > 0.1) { // 10%慢请求
      this.sendAlert('high_slow_request_rate', {
        current: slowRate,
        threshold: 0.1
      });
    }
    
    // 检查内存使用率
    if ('memory' in performance) {
      const memoryUsage = performance.memory.usedJSHeapSize / performance.memory.jsHeapSizeLimit;
      if (memoryUsage > this.thresholds.memoryUsage) {
        this.sendAlert('high_memory_usage', {
          current: memoryUsage,
          threshold: this.thresholds.memoryUsage
        });
      }
    }
  }

  // 发送告警
  sendAlert(type, data) {
    const alert = {
      type,
      data,
      timestamp: Date.now(),
      url: window.location.href,
      userAgent: navigator.userAgent
    };
    
    // 发送到告警系统
    console.log('Alert sent:', alert);
    
    // 可以集成钉钉、企业微信等通知
    this.sendNotification(alert);
  }

  // 发送通知
  sendNotification(alert) {
    // 示例：发送到钉钉
    fetch('/api/alert', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(alert)
    });
  }
}
```

## 🎯 面试技巧总结

### 回答策略

**1. 系统设计**
- 理解监控系统的整体架构
- 说明各个模块的职责和作用

**2. 技术实现**
- 展示实际的代码实现
- 说明错误捕获和上报机制

**3. 性能考虑**
- 理解监控系统对性能的影响
- 掌握优化策略

### 加分点

1. **全面性**：展示完整的监控体系
2. **实时性**：强调实时告警和响应
3. **可扩展性**：说明系统的扩展能力
4. **实用性**：分享实际的应用案例

### 常见误区

1. **只关注错误捕获**：要理解完整的监控体系
2. **忽视性能影响**：要注意监控系统的性能开销
3. **缺乏告警机制**：要重视实时告警的重要性
4. **没有数据分析**：要关注数据的分析和利用

### 面试准备清单

- [ ] 理解异常监控系统的架构
- [ ] 掌握错误捕获和上报机制
- [ ] 了解性能监控方法
- [ ] 掌握错误分类和聚合
- [ ] 了解实时告警机制
- [ ] 准备实际项目案例

## 💡 总结

异常监控系统在前端开发中主要用于：
1. **错误追踪**：及时发现和定位问题
2. **性能监控**：监控应用性能指标
3. **用户体验**：提升应用稳定性
4. **数据分析**：为优化提供数据支持

面试时要重点展示：
- 对监控系统架构的理解
- 实际的代码实现经验
- 性能优化和告警机制
- 数据分析和利用能力 