# 计算机原理相关问题 - 前端面试指南

## 📋 常见面试题与答案

### Q1: 什么是DNS解析？前端开发中如何优化DNS？

**标准答案：**
DNS（Domain Name System）是将域名转换为IP地址的系统。

**前端开发中的DNS优化：**
1. **DNS预解析**：提前解析域名
2. **CDN使用**：减少DNS查询次数
3. **域名收敛**：减少域名数量

**面试回答技巧：**
```html
<!-- DNS预解析 -->
<link rel="dns-prefetch" href="//api.example.com">
<link rel="dns-prefetch" href="//cdn.example.com">

<!-- 预连接 -->
<link rel="preconnect" href="https://api.example.com">
<link rel="preconnect" href="https://cdn.example.com" crossorigin>
```

```javascript
// DNS解析过程示例
class DNSResolver {
  constructor() {
    this.cache = new Map();
  }

  async resolve(domain) {
    // 检查缓存
    if (this.cache.has(domain)) {
      return this.cache.get(domain);
    }

    // 模拟DNS解析过程
    const ip = await this.queryDNS(domain);
    this.cache.set(domain, ip);
    return ip;
  }

  async queryDNS(domain) {
    // 1. 检查本地hosts文件
    // 2. 查询本地DNS缓存
    // 3. 查询本地DNS服务器
    // 4. 查询根DNS服务器
    // 5. 查询顶级域名服务器
    // 6. 查询权威DNS服务器
    
    console.log(`Resolving ${domain}...`);
    return '192.168.1.1'; // 模拟返回IP
  }
}
```

### Q2: HTTP协议的工作原理是什么？

**标准答案：**
HTTP是基于请求-响应模式的协议，客户端发送请求，服务器返回响应。

**面试回答技巧：**
```javascript
// HTTP请求示例
class HTTPClient {
  async request(method, url, data = null) {
    const xhr = new XMLHttpRequest();
    
    return new Promise((resolve, reject) => {
      xhr.open(method, url);
      xhr.setRequestHeader('Content-Type', 'application/json');
      
      xhr.onload = () => {
        if (xhr.status >= 200 && xhr.status < 300) {
          resolve({
            status: xhr.status,
            data: JSON.parse(xhr.responseText)
          });
        } else {
          reject(new Error(`HTTP ${xhr.status}`));
        }
      };
      
      xhr.onerror = () => reject(new Error('Network error'));
      xhr.send(data ? JSON.stringify(data) : null);
    });
  }

  get(url) {
    return this.request('GET', url);
  }

  post(url, data) {
    return this.request('POST', url, data);
  }
}
```

### Q3: HTTPS和HTTP的区别是什么？

**标准答案：**
HTTPS在HTTP基础上增加了SSL/TLS加密层，提供数据传输的安全性。

**面试回答技巧：**
```javascript
// HTTPS证书验证示例
class HTTPSValidator {
  validateCertificate(cert) {
    // 检查证书有效期
    const now = new Date();
    const validFrom = new Date(cert.validFrom);
    const validTo = new Date(cert.validTo);
    
    if (now < validFrom || now > validTo) {
      throw new Error('Certificate expired or not yet valid');
    }
    
    // 检查证书链
    return this.verifyCertificateChain(cert);
  }

  verifyCertificateChain(cert) {
    // 验证证书链的完整性
    console.log('Verifying certificate chain...');
    return true;
  }
}
```

### Q4: TCP三次握手和四次挥手的原理是什么？

**标准答案：**
三次握手建立连接，四次挥手断开连接。

**面试回答技巧：**
```javascript
// TCP连接状态机示例
class TCPConnection {
  constructor() {
    this.state = 'CLOSED';
  }

  // 三次握手
  connect() {
    console.log('1. Client -> SYN -> Server');
    this.state = 'SYN_SENT';
    
    console.log('2. Server -> SYN + ACK -> Client');
    this.state = 'ESTABLISHED';
    
    console.log('3. Client -> ACK -> Server');
    console.log('Connection established');
  }

  // 四次挥手
  disconnect() {
    console.log('1. Client -> FIN -> Server');
    this.state = 'FIN_WAIT_1';
    
    console.log('2. Server -> ACK -> Client');
    this.state = 'FIN_WAIT_2';
    
    console.log('3. Server -> FIN -> Client');
    this.state = 'TIME_WAIT';
    
    console.log('4. Client -> ACK -> Server');
    this.state = 'CLOSED';
    console.log('Connection closed');
  }
}
```

### Q5: 什么是跨域？如何解决？

**标准答案：**
跨域是浏览器的同源策略限制，不同源的请求会被阻止。

**面试回答技巧：**
```javascript
// CORS代理服务器示例
const express = require('express');
const { createProxyMiddleware } = require('http-proxy-middleware');

const app = express();

// CORS中间件
app.use((req, res, next) => {
  res.header('Access-Control-Allow-Origin', '*');
  res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE');
  res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization');
  
  if (req.method === 'OPTIONS') {
    res.sendStatus(200);
  } else {
    next();
  }
});

// 代理配置
app.use('/api', createProxyMiddleware({
  target: 'https://api.example.com',
  changeOrigin: true,
  pathRewrite: {
    '^/api': ''
  }
}));
```

```javascript
// 前端跨域解决方案
class CrossOriginHandler {
  // JSONP方式
  jsonp(url, callback) {
    const script = document.createElement('script');
    const callbackName = 'jsonp_' + Date.now();
    
    window[callbackName] = (data) => {
      callback(data);
      document.head.removeChild(script);
      delete window[callbackName];
    };
    
    script.src = `${url}?callback=${callbackName}`;
    document.head.appendChild(script);
  }

  // PostMessage方式
  postMessage(target, message, origin = '*') {
    target.postMessage(message, origin);
  }
}
```

### Q6: 什么是缓存？前端如何实现缓存？

**标准答案：**
缓存是存储数据副本的机制，提高访问速度。

**面试回答技巧：**
```javascript
// 前端缓存实现
class CacheManager {
  constructor() {
    this.memoryCache = new Map();
    this.storageCache = window.localStorage;
  }

  // 内存缓存
  setMemoryCache(key, value, ttl = 300000) { // 5分钟默认过期
    this.memoryCache.set(key, {
      value,
      expire: Date.now() + ttl
    });
  }

  getMemoryCache(key) {
    const item = this.memoryCache.get(key);
    if (!item) return null;
    
    if (Date.now() > item.expire) {
      this.memoryCache.delete(key);
      return null;
    }
    
    return item.value;
  }

  // 本地存储缓存
  setStorageCache(key, value, ttl = 3600000) { // 1小时默认过期
    const item = {
      value,
      expire: Date.now() + ttl
    };
    this.storageCache.setItem(key, JSON.stringify(item));
  }

  getStorageCache(key) {
    const item = this.storageCache.getItem(key);
    if (!item) return null;
    
    const data = JSON.parse(item);
    if (Date.now() > data.expire) {
      this.storageCache.removeItem(key);
      return null;
    }
    
    return data.value;
  }
}
```

### Q7: 什么是负载均衡？前端如何实现？

**标准答案：**
负载均衡是将请求分发到多个服务器，提高系统性能和可用性。

**面试回答技巧：**
```javascript
// 前端负载均衡示例
class LoadBalancer {
  constructor(servers) {
    this.servers = servers;
    this.currentIndex = 0;
    this.healthChecks = new Map();
  }

  // 轮询算法
  roundRobin() {
    const server = this.servers[this.currentIndex];
    this.currentIndex = (this.currentIndex + 1) % this.servers.length;
    return server;
  }

  // 随机算法
  random() {
    const index = Math.floor(Math.random() * this.servers.length);
    return this.servers[index];
  }

  // 健康检查
  async healthCheck(server) {
    try {
      const response = await fetch(`${server}/health`);
      return response.ok;
    } catch (error) {
      return false;
    }
  }

  // 获取可用服务器
  async getAvailableServer() {
    const availableServers = [];
    
    for (const server of this.servers) {
      const isHealthy = await this.healthCheck(server);
      if (isHealthy) {
        availableServers.push(server);
      }
    }
    
    return availableServers.length > 0 
      ? this.roundRobin() 
      : null;
  }
}
```

## 🎯 面试技巧总结

### 回答策略

**1. 概念理解**
- 理解网络协议的基本原理
- 解释为什么需要这些机制

**2. 实践经验**
- 展示实际的代码实现
- 说明优化策略和最佳实践

**3. 技术深度**
- 理解底层原理和实现细节
- 掌握性能优化方法

### 加分点

1. **性能优化意识**：主动提及DNS优化、缓存策略
2. **安全考虑**：说明HTTPS、CORS等安全机制
3. **实际经验**：分享真实的网络问题解决案例
4. **技术深度**：展示对底层原理的理解

### 常见误区

1. **只知其然不知其所以然**：要理解协议的工作原理
2. **忽视性能**：要注意网络性能优化
3. **缺乏安全意识**：要重视网络安全
4. **没有实践经验**：要有实际的问题解决经验

### 面试准备清单

- [ ] 理解DNS解析过程和优化方法
- [ ] 掌握HTTP/HTTPS协议原理
- [ ] 了解TCP连接建立和断开过程
- [ ] 掌握跨域解决方案
- [ ] 了解缓存机制和实现
- [ ] 准备实际项目案例

## 💡 总结

计算机原理在前端开发中主要用于：
1. **网络优化**：DNS解析、CDN使用、协议优化
2. **性能提升**：缓存策略、负载均衡
3. **安全保障**：HTTPS、CORS、证书验证
4. **问题排查**：网络问题诊断和解决

面试时要重点展示：
- 对网络协议原理的理解
- 实际的性能优化经验
- 安全意识和最佳实践
- 问题排查和解决能力 