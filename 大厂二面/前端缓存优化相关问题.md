# å‰ç«¯ç¼“å­˜ä¼˜åŒ–ç›¸å…³é—®é¢˜ - å‰ç«¯é¢è¯•æŒ‡å—

## ğŸ“‹ å¸¸è§é¢è¯•é¢˜ä¸ç­”æ¡ˆ

### Q1: å‰ç«¯ç¼“å­˜æœ‰å“ªäº›ç±»å‹ï¼Ÿå¦‚ä½•é€‰æ‹©åˆé€‚çš„ç¼“å­˜ç­–ç•¥ï¼Ÿ

**æ ‡å‡†ç­”æ¡ˆï¼š**
å‰ç«¯ç¼“å­˜åŒ…æ‹¬HTTPç¼“å­˜ã€æµè§ˆå™¨ç¼“å­˜ã€Service Workerç¼“å­˜ã€å†…å­˜ç¼“å­˜ç­‰ã€‚

**é¢è¯•å›ç­”æŠ€å·§ï¼š**
```javascript
// å‰ç«¯ç¼“å­˜ç±»å‹å’Œç­–ç•¥
class CacheManager {
  constructor() {
    this.memoryCache = new Map();
    this.storageCache = window.localStorage;
    this.sessionCache = window.sessionStorage;
  }

  // 1. HTTPç¼“å­˜ç­–ç•¥
  setHTTPCacheHeaders(response, maxAge = 3600) {
    response.headers.set('Cache-Control', `max-age=${maxAge}`);
    response.headers.set('ETag', this.generateETag(response));
    response.headers.set('Last-Modified', new Date().toUTCString());
    return response;
  }

  // 2. å†…å­˜ç¼“å­˜
  setMemoryCache(key, value, ttl = 300000) { // 5åˆ†é’Ÿé»˜è®¤è¿‡æœŸ
    this.memoryCache.set(key, {
      value,
      expire: Date.now() + ttl
    });
  }

  getMemoryCache(key) {
    const item = this.memoryCache.get(key);
    if (!item) return null;
    
    if (Date.now() > item.expire) {
      this.memoryCache.delete(key);
      return null;
    }
    
    return item.value;
  }

  // 3. æœ¬åœ°å­˜å‚¨ç¼“å­˜
  setLocalStorageCache(key, value, ttl = 3600000) { // 1å°æ—¶é»˜è®¤è¿‡æœŸ
    const item = {
      value,
      timestamp: Date.now(),
      ttl
    };
    this.storageCache.setItem(key, JSON.stringify(item));
  }

  getLocalStorageCache(key) {
    const item = this.storageCache.getItem(key);
    if (!item) return null;
    
    const data = JSON.parse(item);
    if (Date.now() - data.timestamp > data.ttl) {
      this.storageCache.removeItem(key);
      return null;
    }
    
    return data.value;
  }

  // 4. Sessionå­˜å‚¨ç¼“å­˜
  setSessionCache(key, value) {
    this.sessionCache.setItem(key, JSON.stringify(value));
  }

  getSessionCache(key) {
    const item = this.sessionCache.getItem(key);
    return item ? JSON.parse(item) : null;
  }

  // 5. IndexedDBç¼“å­˜
  async setupIndexedDB() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open('CacheDB', 1);
      
      request.onerror = () => reject(request.error);
      request.onsuccess = () => resolve(request.result);
      
      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        if (!db.objectStoreNames.contains('cache')) {
          db.createObjectStore('cache', { keyPath: 'key' });
        }
      };
    });
  }

  // ç¼“å­˜ç­–ç•¥é€‰æ‹©
  chooseCacheStrategy(dataType, accessFrequency, dataSize) {
    if (dataSize > 1024 * 1024) { // å¤§äº1MB
      return 'indexeddb'; // å¤§æ–‡ä»¶ç”¨IndexedDB
    }
    
    if (accessFrequency === 'high') {
      return 'memory'; // é«˜é¢‘è®¿é—®ç”¨å†…å­˜ç¼“å­˜
    }
    
    if (dataType === 'session') {
      return 'session'; // ä¼šè¯æ•°æ®ç”¨SessionStorage
    }
    
    return 'localstorage'; // é»˜è®¤ç”¨LocalStorage
  }
}
```

### Q2: å¦‚ä½•å®ç°Service Workerç¼“å­˜ï¼Ÿ

**æ ‡å‡†ç­”æ¡ˆï¼š**
ä½¿ç”¨Service Workerå®ç°ç¦»çº¿ç¼“å­˜ã€èµ„æºç¼“å­˜ã€APIç¼“å­˜ç­‰ã€‚

**é¢è¯•å›ç­”æŠ€å·§ï¼š**
```javascript
// Service Workerç¼“å­˜å®ç°
// sw.js
const CACHE_NAME = 'app-cache-v1';
const STATIC_CACHE = 'static-cache-v1';
const DYNAMIC_CACHE = 'dynamic-cache-v1';

const STATIC_ASSETS = [
  '/',
  '/index.html',
  '/static/js/main.js',
  '/static/css/style.css',
  '/static/images/logo.png'
];

// å®‰è£…é˜¶æ®µï¼šç¼“å­˜é™æ€èµ„æº
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(STATIC_CACHE)
      .then(cache => {
        console.log('Caching static assets');
        return cache.addAll(STATIC_ASSETS);
      })
  );
});

// æ¿€æ´»é˜¶æ®µï¼šæ¸…ç†æ—§ç¼“å­˜
self.addEventListener('activate', (event) => {
  event.waitUntil(
    caches.keys()
      .then(cacheNames => {
        return Promise.all(
          cacheNames.map(cacheName => {
            if (cacheName !== STATIC_CACHE && cacheName !== DYNAMIC_CACHE) {
              console.log('Deleting old cache:', cacheName);
              return caches.delete(cacheName);
            }
          })
        );
      })
  );
});

// æ‹¦æˆªè¯·æ±‚ï¼šå®ç°ç¼“å­˜ç­–ç•¥
self.addEventListener('fetch', (event) => {
  const { request } = event;
  const url = new URL(request.url);

  // é™æ€èµ„æºï¼šCache Firstç­–ç•¥
  if (STATIC_ASSETS.includes(url.pathname)) {
    event.respondWith(cacheFirst(request, STATIC_CACHE));
    return;
  }

  // APIè¯·æ±‚ï¼šNetwork Firstç­–ç•¥
  if (url.pathname.startsWith('/api/')) {
    event.respondWith(networkFirst(request, DYNAMIC_CACHE));
    return;
  }

  // å…¶ä»–èµ„æºï¼šStale While Revalidateç­–ç•¥
  event.respondWith(staleWhileRevalidate(request, DYNAMIC_CACHE));
});

// Cache Firstç­–ç•¥
async function cacheFirst(request, cacheName) {
  const cachedResponse = await caches.match(request);
  if (cachedResponse) {
    return cachedResponse;
  }
  
  try {
    const networkResponse = await fetch(request);
    const cache = await caches.open(cacheName);
    cache.put(request, networkResponse.clone());
    return networkResponse;
  } catch (error) {
    return new Response('Network error', { status: 503 });
  }
}

// Network Firstç­–ç•¥
async function networkFirst(request, cacheName) {
  try {
    const networkResponse = await fetch(request);
    const cache = await caches.open(cacheName);
    cache.put(request, networkResponse.clone());
    return networkResponse;
  } catch (error) {
    const cachedResponse = await caches.match(request);
    if (cachedResponse) {
      return cachedResponse;
    }
    return new Response('Network error', { status: 503 });
  }
}

// Stale While Revalidateç­–ç•¥
async function staleWhileRevalidate(request, cacheName) {
  const cache = await caches.open(cacheName);
  const cachedResponse = await cache.match(request);
  
  const networkResponsePromise = fetch(request).then(response => {
    cache.put(request, response.clone());
    return response;
  });
  
  return cachedResponse || networkResponsePromise;
}

// æ³¨å†ŒService Worker
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('/sw.js')
      .then(registration => {
        console.log('SW registered:', registration);
      })
      .catch(error => {
        console.log('SW registration failed:', error);
      });
  });
}
```

### Q3: å¦‚ä½•å®ç°æ™ºèƒ½ç¼“å­˜ç­–ç•¥ï¼Ÿ

**æ ‡å‡†ç­”æ¡ˆï¼š**
æ ¹æ®èµ„æºç±»å‹ã€è®¿é—®é¢‘ç‡ã€æ•°æ®å¤§å°ç­‰å®ç°æ™ºèƒ½ç¼“å­˜ç­–ç•¥ã€‚

**é¢è¯•å›ç­”æŠ€å·§ï¼š**
```javascript
// æ™ºèƒ½ç¼“å­˜ç­–ç•¥å®ç°
class SmartCache {
  constructor() {
    this.cacheStats = new Map();
    this.cachePolicies = new Map();
  }

  // ç¼“å­˜ç­–ç•¥æšä¸¾
  static POLICY = {
    CACHE_FIRST: 'cache-first',
    NETWORK_FIRST: 'network-first',
    STALE_WHILE_REVALIDATE: 'stale-while-revalidate',
    NETWORK_ONLY: 'network-only',
    CACHE_ONLY: 'cache-only'
  };

  // æ ¹æ®èµ„æºç±»å‹é€‰æ‹©ç­–ç•¥
  selectPolicy(url, resourceType) {
    const urlObj = new URL(url);
    
    // é™æ€èµ„æºï¼šCache First
    if (resourceType === 'script' || resourceType === 'style' || resourceType === 'image') {
      return SmartCache.POLICY.CACHE_FIRST;
    }
    
    // APIè¯·æ±‚ï¼šNetwork First
    if (urlObj.pathname.startsWith('/api/')) {
      return SmartCache.POLICY.NETWORK_FIRST;
    }
    
    // HTMLé¡µé¢ï¼šStale While Revalidate
    if (resourceType === 'document') {
      return SmartCache.POLICY.STALE_WHILE_REVALIDATE;
    }
    
    // åŠ¨æ€å†…å®¹ï¼šNetwork Only
    return SmartCache.POLICY.NETWORK_ONLY;
  }

  // æ™ºèƒ½ç¼“å­˜å®ç°
  async smartCache(request, policy) {
    const cache = await caches.open('smart-cache');
    
    switch (policy) {
      case SmartCache.POLICY.CACHE_FIRST:
        return this.cacheFirst(request, cache);
      case SmartCache.POLICY.NETWORK_FIRST:
        return this.networkFirst(request, cache);
      case SmartCache.POLICY.STALE_WHILE_REVALIDATE:
        return this.staleWhileRevalidate(request, cache);
      case SmartCache.POLICY.NETWORK_ONLY:
        return this.networkOnly(request);
      case SmartCache.POLICY.CACHE_ONLY:
        return this.cacheOnly(request, cache);
      default:
        return this.networkOnly(request);
    }
  }

  // Cache Firstç­–ç•¥
  async cacheFirst(request, cache) {
    const cachedResponse = await cache.match(request);
    if (cachedResponse) {
      this.updateStats(request.url, 'cache_hit');
      return cachedResponse;
    }
    
    try {
      const networkResponse = await fetch(request);
      if (networkResponse.ok) {
        cache.put(request, networkResponse.clone());
        this.updateStats(request.url, 'cache_miss');
      }
      return networkResponse;
    } catch (error) {
      this.updateStats(request.url, 'network_error');
      throw error;
    }
  }

  // Network Firstç­–ç•¥
  async networkFirst(request, cache) {
    try {
      const networkResponse = await fetch(request);
      if (networkResponse.ok) {
        cache.put(request, networkResponse.clone());
        this.updateStats(request.url, 'network_success');
      }
      return networkResponse;
    } catch (error) {
      const cachedResponse = await cache.match(request);
      if (cachedResponse) {
        this.updateStats(request.url, 'cache_fallback');
        return cachedResponse;
      }
      this.updateStats(request.url, 'network_error');
      throw error;
    }
  }

  // Stale While Revalidateç­–ç•¥
  async staleWhileRevalidate(request, cache) {
    const cachedResponse = await cache.match(request);
    
    const networkResponsePromise = fetch(request).then(response => {
      if (response.ok) {
        cache.put(request, response.clone());
        this.updateStats(request.url, 'revalidate_success');
      }
      return response;
    }).catch(error => {
      this.updateStats(request.url, 'revalidate_error');
      throw error;
    });
    
    if (cachedResponse) {
      this.updateStats(request.url, 'stale_served');
      return cachedResponse;
    }
    
    return networkResponsePromise;
  }

  // æ›´æ–°ç¼“å­˜ç»Ÿè®¡
  updateStats(url, event) {
    if (!this.cacheStats.has(url)) {
      this.cacheStats.set(url, {
        hits: 0,
        misses: 0,
        errors: 0,
        lastAccess: Date.now()
      });
    }
    
    const stats = this.cacheStats.get(url);
    stats.lastAccess = Date.now();
    
    switch (event) {
      case 'cache_hit':
        stats.hits++;
        break;
      case 'cache_miss':
      case 'network_success':
        stats.misses++;
        break;
      case 'network_error':
        stats.errors++;
        break;
    }
  }

  // è·å–ç¼“å­˜æ€§èƒ½æŠ¥å‘Š
  getCacheReport() {
    const report = {
      totalRequests: 0,
      cacheHitRate: 0,
      averageResponseTime: 0,
      topCachedUrls: []
    };
    
    let totalHits = 0;
    let totalRequests = 0;
    
    for (const [url, stats] of this.cacheStats) {
      const urlRequests = stats.hits + stats.misses;
      totalHits += stats.hits;
      totalRequests += urlRequests;
      
      report.topCachedUrls.push({
        url,
        hitRate: stats.hits / urlRequests,
        totalRequests: urlRequests
      });
    }
    
    report.totalRequests = totalRequests;
    report.cacheHitRate = totalRequests > 0 ? totalHits / totalRequests : 0;
    report.topCachedUrls.sort((a, b) => b.hitRate - a.hitRate);
    
    return report;
  }
}
```

### Q4: å¦‚ä½•å®ç°ç¼“å­˜é¢„çƒ­å’Œé¢„åŠ è½½ï¼Ÿ

**æ ‡å‡†ç­”æ¡ˆï¼š**
é€šè¿‡é¢„åŠ è½½å…³é”®èµ„æºã€é¢„çƒ­ç¼“å­˜æ•°æ®ç­‰æ–¹å¼æå‡ç”¨æˆ·ä½“éªŒã€‚

**é¢è¯•å›ç­”æŠ€å·§ï¼š**
```javascript
// ç¼“å­˜é¢„çƒ­å’Œé¢„åŠ è½½å®ç°
class CachePreloader {
  constructor() {
    this.preloadQueue = [];
    this.isPreloading = false;
  }

  // é¢„åŠ è½½å…³é”®èµ„æº
  preloadCriticalResources() {
    const criticalResources = [
      '/api/user/profile',
      '/api/navigation/menu',
      '/static/js/main.js',
      '/static/css/style.css'
    ];
    
    criticalResources.forEach(resource => {
      this.preloadResource(resource);
    });
  }

  // é¢„åŠ è½½å•ä¸ªèµ„æº
  async preloadResource(url, options = {}) {
    const { priority = 'low', type = 'fetch' } = options;
    
    if (type === 'fetch') {
      try {
        const response = await fetch(url, { 
          method: 'GET',
          headers: { 'X-Preload': 'true' }
        });
        
        if (response.ok) {
          const cache = await caches.open('preload-cache');
          cache.put(url, response.clone());
          console.log(`Preloaded: ${url}`);
        }
      } catch (error) {
        console.warn(`Failed to preload: ${url}`, error);
      }
    } else if (type === 'link') {
      const link = document.createElement('link');
      link.rel = 'preload';
      link.href = url;
      link.as = this.getResourceType(url);
      document.head.appendChild(link);
    }
  }

  // è·å–èµ„æºç±»å‹
  getResourceType(url) {
    if (url.endsWith('.js')) return 'script';
    if (url.endsWith('.css')) return 'style';
    if (url.endsWith('.png') || url.endsWith('.jpg') || url.endsWith('.webp')) return 'image';
    return 'fetch';
  }

  // é¢„çƒ­APIç¼“å­˜
  async warmupAPICache() {
    const apiEndpoints = [
      '/api/products/popular',
      '/api/categories',
      '/api/user/preferences'
    ];
    
    const promises = apiEndpoints.map(endpoint => 
      this.preloadResource(endpoint, { priority: 'high' })
    );
    
    await Promise.allSettled(promises);
  }

  // é¢„åŠ è½½ä¸‹ä¸€é¡µæ•°æ®
  preloadNextPage(currentPage, totalPages) {
    if (currentPage < totalPages) {
      const nextPageUrl = `/api/products?page=${currentPage + 1}`;
      this.preloadResource(nextPageUrl, { priority: 'medium' });
    }
  }

  // æ™ºèƒ½é¢„åŠ è½½
  smartPreload() {
    // ç›‘å¬ç”¨æˆ·è¡Œä¸º
    this.observeUserBehavior();
    
    // é¢„åŠ è½½ç”¨æˆ·å¯èƒ½è®¿é—®çš„å†…å®¹
    this.preloadBasedOnBehavior();
  }

  // è§‚å¯Ÿç”¨æˆ·è¡Œä¸º
  observeUserBehavior() {
    // ç›‘å¬é¼ æ ‡æ‚¬åœ
    document.addEventListener('mouseover', (event) => {
      const link = event.target.closest('a');
      if (link && link.href) {
        this.preloadResource(link.href, { priority: 'low' });
      }
    });

    // ç›‘å¬æ»šåŠ¨
    let scrollTimeout;
    document.addEventListener('scroll', () => {
      clearTimeout(scrollTimeout);
      scrollTimeout = setTimeout(() => {
        this.preloadVisibleContent();
      }, 100);
    });
  }

  // é¢„åŠ è½½å¯è§å†…å®¹
  preloadVisibleContent() {
    const visibleElements = this.getVisibleElements();
    
    visibleElements.forEach(element => {
      if (element.dataset.preload) {
        this.preloadResource(element.dataset.preload);
      }
    });
  }

  // è·å–å¯è§å…ƒç´ 
  getVisibleElements() {
    const elements = document.querySelectorAll('[data-preload]');
    const visibleElements = [];
    
    elements.forEach(element => {
      const rect = element.getBoundingClientRect();
      if (rect.top < window.innerHeight && rect.bottom > 0) {
        visibleElements.push(element);
      }
    });
    
    return visibleElements;
  }

  // åŸºäºè¡Œä¸ºçš„é¢„åŠ è½½
  preloadBasedOnBehavior() {
    // æ ¹æ®ç”¨æˆ·å†å²è¡Œä¸ºé¢„æµ‹
    const userBehavior = this.getUserBehavior();
    
    if (userBehavior.frequentlyVisited.includes('/products')) {
      this.preloadResource('/api/products/trending');
    }
    
    if (userBehavior.searchHistory.length > 0) {
      this.preloadResource('/api/search/suggestions');
    }
  }

  // è·å–ç”¨æˆ·è¡Œä¸ºæ•°æ®
  getUserBehavior() {
    return {
      frequentlyVisited: JSON.parse(localStorage.getItem('frequentlyVisited') || '[]'),
      searchHistory: JSON.parse(localStorage.getItem('searchHistory') || '[]'),
      lastVisited: localStorage.getItem('lastVisited')
    };
  }
}
```

### Q5: å¦‚ä½•å®ç°ç¼“å­˜å¤±æ•ˆå’Œæ›´æ–°ç­–ç•¥ï¼Ÿ

**æ ‡å‡†ç­”æ¡ˆï¼š**
é€šè¿‡ç‰ˆæœ¬æ§åˆ¶ã€æ—¶é—´æˆ³ã€ETagç­‰æ–¹å¼å®ç°ç¼“å­˜å¤±æ•ˆå’Œæ›´æ–°ã€‚

**é¢è¯•å›ç­”æŠ€å·§ï¼š**
```javascript
// ç¼“å­˜å¤±æ•ˆå’Œæ›´æ–°ç­–ç•¥
class CacheInvalidation {
  constructor() {
    this.cacheVersion = 'v1.0.0';
    this.cacheTimestamps = new Map();
  }

  // ç‰ˆæœ¬æ§åˆ¶ç¼“å­˜
  async versionedCache(request, response) {
    const cacheKey = `${this.cacheVersion}:${request.url}`;
    const cache = await caches.open('versioned-cache');
    
    const versionedRequest = new Request(cacheKey);
    await cache.put(versionedRequest, response.clone());
    
    return response;
  }

  // æ—¶é—´æˆ³ç¼“å­˜
  async timestampedCache(request, response, maxAge = 3600000) {
    const timestamp = Date.now();
    const cacheKey = `${request.url}?t=${timestamp}`;
    
    const cache = await caches.open('timestamped-cache');
    const timestampedRequest = new Request(cacheKey);
    
    await cache.put(timestampedRequest, response.clone());
    this.cacheTimestamps.set(request.url, timestamp);
    
    return response;
  }

  // ETagç¼“å­˜
  async etagCache(request, response) {
    const etag = response.headers.get('ETag');
    if (!etag) return response;
    
    const cacheKey = `${request.url}?etag=${etag}`;
    const cache = await caches.open('etag-cache');
    const etagRequest = new Request(cacheKey);
    
    await cache.put(etagRequest, response.clone());
    return response;
  }

  // ç¼“å­˜å¤±æ•ˆç­–ç•¥
  async invalidateCache(pattern) {
    const cacheNames = await caches.keys();
    
    for (const cacheName of cacheNames) {
      const cache = await caches.open(cacheName);
      const requests = await cache.keys();
      
      for (const request of requests) {
        if (this.matchesPattern(request.url, pattern)) {
          await cache.delete(request);
          console.log(`Invalidated cache: ${request.url}`);
        }
      }
    }
  }

  // æ¨¡å¼åŒ¹é…
  matchesPattern(url, pattern) {
    if (typeof pattern === 'string') {
      return url.includes(pattern);
    }
    
    if (pattern instanceof RegExp) {
      return pattern.test(url);
    }
    
    if (typeof pattern === 'function') {
      return pattern(url);
    }
    
    return false;
  }

  // æ‰¹é‡ç¼“å­˜å¤±æ•ˆ
  async batchInvalidate(patterns) {
    const invalidationPromises = patterns.map(pattern => 
      this.invalidateCache(pattern)
    );
    
    await Promise.all(invalidationPromises);
  }

  // æ™ºèƒ½ç¼“å­˜æ›´æ–°
  async smartUpdate(request) {
    const cache = await caches.open('smart-cache');
    const cachedResponse = await cache.match(request);
    
    if (!cachedResponse) {
      return this.fetchAndCache(request, cache);
    }
    
    // æ£€æŸ¥ç¼“å­˜æ˜¯å¦è¿‡æœŸ
    const cacheAge = Date.now() - this.getCacheTimestamp(request.url);
    const maxAge = this.getMaxAge(request.url);
    
    if (cacheAge > maxAge) {
      // ç¼“å­˜è¿‡æœŸï¼Œåå°æ›´æ–°
      this.backgroundUpdate(request, cache);
      return cachedResponse; // è¿”å›æ—§ç¼“å­˜
    }
    
    return cachedResponse;
  }

  // è·å–ç¼“å­˜æ—¶é—´æˆ³
  getCacheTimestamp(url) {
    return this.cacheTimestamps.get(url) || 0;
  }

  // è·å–æœ€å¤§ç¼“å­˜æ—¶é—´
  getMaxAge(url) {
    if (url.includes('/api/')) {
      return 5 * 60 * 1000; // APIç¼“å­˜5åˆ†é’Ÿ
    }
    
    if (url.includes('/static/')) {
      return 24 * 60 * 60 * 1000; // é™æ€èµ„æºç¼“å­˜24å°æ—¶
    }
    
    return 60 * 60 * 1000; // é»˜è®¤ç¼“å­˜1å°æ—¶
  }

  // è·å–å¹¶ç¼“å­˜
  async fetchAndCache(request, cache) {
    try {
      const response = await fetch(request);
      if (response.ok) {
        await cache.put(request, response.clone());
        this.cacheTimestamps.set(request.url, Date.now());
      }
      return response;
    } catch (error) {
      console.error('Fetch failed:', error);
      throw error;
    }
  }

  // åå°æ›´æ–°
  async backgroundUpdate(request, cache) {
    fetch(request).then(async response => {
      if (response.ok) {
        await cache.put(request, response.clone());
        this.cacheTimestamps.set(request.url, Date.now());
        console.log('Background cache updated:', request.url);
      }
    }).catch(error => {
      console.warn('Background update failed:', error);
    });
  }

  // ç¼“å­˜å¥åº·æ£€æŸ¥
  async healthCheck() {
    const cacheNames = await caches.keys();
    const healthReport = {
      totalCaches: cacheNames.length,
      totalEntries: 0,
      expiredEntries: 0,
      cacheSizes: {}
    };
    
    for (const cacheName of cacheNames) {
      const cache = await caches.open(cacheName);
      const requests = await cache.keys();
      
      healthReport.totalEntries += requests.length;
      healthReport.cacheSizes[cacheName] = requests.length;
      
      for (const request of requests) {
        const timestamp = this.getCacheTimestamp(request.url);
        const maxAge = this.getMaxAge(request.url);
        
        if (Date.now() - timestamp > maxAge) {
          healthReport.expiredEntries++;
        }
      }
    }
    
    return healthReport;
  }
}
```

### Q6: å¦‚ä½•å®ç°ç¼“å­˜æ€§èƒ½ç›‘æ§ï¼Ÿ

**æ ‡å‡†ç­”æ¡ˆï¼š**
é€šè¿‡ç›‘æ§ç¼“å­˜å‘½ä¸­ç‡ã€å“åº”æ—¶é—´ã€å­˜å‚¨ä½¿ç”¨é‡ç­‰æŒ‡æ ‡ä¼˜åŒ–ç¼“å­˜æ€§èƒ½ã€‚

**é¢è¯•å›ç­”æŠ€å·§ï¼š**
```javascript
// ç¼“å­˜æ€§èƒ½ç›‘æ§
class CachePerformanceMonitor {
  constructor() {
    this.metrics = {
      hits: 0,
      misses: 0,
      errors: 0,
      responseTimes: [],
      storageUsage: 0
    };
    
    this.startTime = Date.now();
  }

  // è®°å½•ç¼“å­˜å‘½ä¸­
  recordHit(url, responseTime) {
    this.metrics.hits++;
    this.metrics.responseTimes.push(responseTime);
    this.logMetric('cache_hit', { url, responseTime });
  }

  // è®°å½•ç¼“å­˜æœªå‘½ä¸­
  recordMiss(url, responseTime) {
    this.metrics.misses++;
    this.metrics.responseTimes.push(responseTime);
    this.logMetric('cache_miss', { url, responseTime });
  }

  // è®°å½•é”™è¯¯
  recordError(url, error) {
    this.metrics.errors++;
    this.logMetric('cache_error', { url, error: error.message });
  }

  // è®°å½•æŒ‡æ ‡
  logMetric(type, data) {
    const metric = {
      type,
      timestamp: Date.now(),
      data
    };
    
    // å‘é€åˆ°ç›‘æ§ç³»ç»Ÿ
    this.sendToMonitoring(metric);
  }

  // å‘é€åˆ°ç›‘æ§ç³»ç»Ÿ
  sendToMonitoring(metric) {
    // å¯ä»¥å‘é€åˆ°Google Analyticsã€è‡ªå»ºç›‘æ§ç³»ç»Ÿç­‰
    if (window.gtag) {
      window.gtag('event', 'cache_metric', {
        event_category: 'cache',
        event_label: metric.type,
        value: 1
      });
    }
    
    // æœ¬åœ°å­˜å‚¨ç”¨äºç¦»çº¿åˆ†æ
    this.storeMetric(metric);
  }

  // å­˜å‚¨æŒ‡æ ‡
  storeMetric(metric) {
    const metrics = JSON.parse(localStorage.getItem('cache_metrics') || '[]');
    metrics.push(metric);
    
    // åªä¿ç•™æœ€è¿‘1000æ¡è®°å½•
    if (metrics.length > 1000) {
      metrics.splice(0, metrics.length - 1000);
    }
    
    localStorage.setItem('cache_metrics', JSON.stringify(metrics));
  }

  // è·å–æ€§èƒ½æŠ¥å‘Š
  getPerformanceReport() {
    const totalRequests = this.metrics.hits + this.metrics.misses;
    const hitRate = totalRequests > 0 ? this.metrics.hits / totalRequests : 0;
    const averageResponseTime = this.metrics.responseTimes.length > 0 
      ? this.metrics.responseTimes.reduce((a, b) => a + b, 0) / this.metrics.responseTimes.length 
      : 0;
    
    return {
      hitRate: hitRate.toFixed(2),
      averageResponseTime: averageResponseTime.toFixed(2),
      totalRequests,
      errorRate: totalRequests > 0 ? this.metrics.errors / totalRequests : 0,
      uptime: Date.now() - this.startTime
    };
  }

  // ç›‘æ§å­˜å‚¨ä½¿ç”¨é‡
  async monitorStorageUsage() {
    if ('storage' in navigator && 'estimate' in navigator.storage) {
      const estimate = await navigator.storage.estimate();
      this.metrics.storageUsage = estimate.usage || 0;
      
      return {
        used: estimate.usage,
        quota: estimate.quota,
        usagePercentage: estimate.usage && estimate.quota 
          ? (estimate.usage / estimate.quota * 100).toFixed(2) 
          : 0
      };
    }
    
    return null;
  }

  // ç¼“å­˜æ€§èƒ½ä¼˜åŒ–å»ºè®®
  getOptimizationSuggestions() {
    const report = this.getPerformanceReport();
    const suggestions = [];
    
    if (report.hitRate < 0.5) {
      suggestions.push('ç¼“å­˜å‘½ä¸­ç‡è¾ƒä½ï¼Œå»ºè®®å¢åŠ ç¼“å­˜ç­–ç•¥');
    }
    
    if (report.averageResponseTime > 1000) {
      suggestions.push('å¹³å‡å“åº”æ—¶é—´è¾ƒé•¿ï¼Œå»ºè®®ä¼˜åŒ–ç¼“å­˜ç­–ç•¥');
    }
    
    if (report.errorRate > 0.1) {
      suggestions.push('é”™è¯¯ç‡è¾ƒé«˜ï¼Œå»ºè®®æ£€æŸ¥ç¼“å­˜å®ç°');
    }
    
    return suggestions;
  }

  // å®æ—¶æ€§èƒ½ç›‘æ§
  startRealTimeMonitoring() {
    setInterval(() => {
      const report = this.getPerformanceReport();
      console.log('Cache Performance Report:', report);
      
      // å‘é€åˆ°ç›‘æ§ç³»ç»Ÿ
      this.sendPerformanceReport(report);
    }, 60000); // æ¯åˆ†é’ŸæŠ¥å‘Šä¸€æ¬¡
  }

  // å‘é€æ€§èƒ½æŠ¥å‘Š
  sendPerformanceReport(report) {
    fetch('/api/monitoring/cache-performance', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(report)
    }).catch(error => {
      console.warn('Failed to send performance report:', error);
    });
  }
}
```

## ğŸ¯ é¢è¯•æŠ€å·§æ€»ç»“

### å›ç­”ç­–ç•¥

**1. ç¼“å­˜ç­–ç•¥ç†è§£**
- ç†è§£ä¸åŒç¼“å­˜ç­–ç•¥çš„é€‚ç”¨åœºæ™¯
- èƒ½å¤Ÿåˆ†æç¼“å­˜ç­–ç•¥çš„ä¼˜ç¼ºç‚¹

**2. æ€§èƒ½ä¼˜åŒ–**
- å±•ç¤ºå®é™…çš„æ€§èƒ½ä¼˜åŒ–ä»£ç 
- è¯´æ˜ç¼“å­˜å¯¹æ€§èƒ½çš„å½±å“

**3. å®é™…åº”ç”¨**
- ç»“åˆå‰ç«¯å®é™…åœºæ™¯
- å±•ç¤ºç¼“å­˜çš„å®é™…ä»·å€¼

### åŠ åˆ†ç‚¹

1. **æ€§èƒ½æ„è¯†**ï¼šä¸»åŠ¨æåŠæ€§èƒ½ä¼˜åŒ–ç­–ç•¥
2. **ç”¨æˆ·ä½“éªŒ**ï¼šå¼ºè°ƒç¼“å­˜å¯¹ç”¨æˆ·ä½“éªŒçš„æå‡
3. **æŠ€æœ¯æ·±åº¦**ï¼šå±•ç¤ºå¯¹ç¼“å­˜æœºåˆ¶çš„æ·±å…¥ç†è§£
4. **å®é™…ç»éªŒ**ï¼šåˆ†äº«çœŸå®çš„ç¼“å­˜ä¼˜åŒ–æ¡ˆä¾‹

### å¸¸è§è¯¯åŒº

1. **åªå…³æ³¨ç¼“å­˜**ï¼šè¦ç†è§£å®Œæ•´çš„æ€§èƒ½ä¼˜åŒ–ä½“ç³»
2. **å¿½è§†å¤±æ•ˆ**ï¼šè¦æ³¨æ„ç¼“å­˜å¤±æ•ˆå’Œæ›´æ–°ç­–ç•¥
3. **ç¼ºä¹ç›‘æ§**ï¼šè¦é‡è§†ç¼“å­˜æ€§èƒ½ç›‘æ§
4. **ä¸ç»“åˆåœºæ™¯**ï¼šè¦ç»“åˆå…·ä½“çš„ä¸šåŠ¡åœºæ™¯

### é¢è¯•å‡†å¤‡æ¸…å•

- [ ] ç†è§£å‰ç«¯ç¼“å­˜ç±»å‹å’Œç­–ç•¥
- [ ] æŒæ¡Service Workerç¼“å­˜å®ç°
- [ ] äº†è§£æ™ºèƒ½ç¼“å­˜ç­–ç•¥
- [ ] æŒæ¡ç¼“å­˜é¢„çƒ­å’Œé¢„åŠ è½½
- [ ] äº†è§£ç¼“å­˜å¤±æ•ˆå’Œæ›´æ–°ç­–ç•¥
- [ ] å‡†å¤‡å®é™…é¡¹ç›®æ¡ˆä¾‹

## ğŸ’¡ æ€»ç»“

å‰ç«¯ç¼“å­˜ä¼˜åŒ–ä¸»è¦ç”¨äºï¼š
1. **æ€§èƒ½æå‡**ï¼šå‡å°‘ç½‘ç»œè¯·æ±‚ï¼Œæé«˜å“åº”é€Ÿåº¦
2. **ç”¨æˆ·ä½“éªŒ**ï¼šæä¾›ç¦»çº¿è®¿é—®èƒ½åŠ›ï¼Œå‡å°‘åŠ è½½æ—¶é—´
3. **æˆæœ¬æ§åˆ¶**ï¼šå‡å°‘æœåŠ¡å™¨è´Ÿè½½ï¼Œé™ä½å¸¦å®½æˆæœ¬
4. **å¯é æ€§**ï¼šæä¾›å®¹é”™æœºåˆ¶ï¼Œæé«˜åº”ç”¨ç¨³å®šæ€§

é¢è¯•æ—¶è¦é‡ç‚¹å±•ç¤ºï¼š
- å¯¹ç¼“å­˜ç­–ç•¥çš„æ·±å…¥ç†è§£
- å®é™…çš„æ€§èƒ½ä¼˜åŒ–ç»éªŒ
- ç”¨æˆ·ä½“éªŒå’Œæˆæœ¬æ§åˆ¶æ„è¯†
- ç›‘æ§å’Œä¼˜åŒ–èƒ½åŠ› 