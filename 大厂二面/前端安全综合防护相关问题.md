# å‰ç«¯å®‰å…¨ç»¼åˆé˜²æŠ¤ç›¸å…³é—®é¢˜ - å‰ç«¯é¢è¯•æŒ‡å—

## ğŸ“‹ å¸¸è§é¢è¯•é¢˜ä¸ç­”æ¡ˆ

### Q1: ä»€ä¹ˆæ˜¯XSSæ”»å‡»ï¼Ÿå¦‚ä½•é˜²æŠ¤ï¼Ÿ

**æ ‡å‡†ç­”æ¡ˆï¼š**
XSSï¼ˆCross-Site Scriptingï¼‰æ˜¯æ¶æ„è„šæœ¬æ³¨å…¥æ”»å‡»ï¼Œåˆ†ä¸ºå­˜å‚¨å‹ã€åå°„å‹ã€DOMå‹ä¸‰ç§ç±»å‹ã€‚

**é¢è¯•å›ç­”æŠ€å·§ï¼š**
```javascript
// XSSæ”»å‡»ç±»å‹å’Œé˜²æŠ¤
class XSSProtection {
  // 1. å­˜å‚¨å‹XSSé˜²æŠ¤
  sanitizeInput(input) {
    // HTMLå®ä½“ç¼–ç 
    const htmlEntities = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#x27;',
      '/': '&#x2F;'
    };
    
    return input.replace(/[&<>"'/]/g, (match) => htmlEntities[match]);
  }

  // 2. è¾“å‡ºç¼–ç 
  escapeHTML(str) {
    const div = document.createElement('div');
    div.textContent = str;
    return div.innerHTML;
  }

  // 3. å®‰å…¨çš„DOMæ“ä½œ
  safeSetInnerHTML(element, content) {
    // ä½¿ç”¨DOMPurifyåº“è¿›è¡Œæ¸…ç†
    if (window.DOMPurify) {
      element.innerHTML = DOMPurify.sanitize(content);
    } else {
      // æ‰‹åŠ¨æ¸…ç†
      element.textContent = content;
    }
  }

  // 4. CSPè®¾ç½®
  setCSPHeaders() {
    // æœåŠ¡ç«¯è®¾ç½®CSPå¤´
    const cspPolicy = [
      "default-src 'self'",
      "script-src 'self' 'unsafe-inline' https://trusted-cdn.com",
      "style-src 'self' 'unsafe-inline'",
      "img-src 'self' data: https:",
      "connect-src 'self' https://api.example.com",
      "font-src 'self' https://fonts.googleapis.com",
      "object-src 'none'",
      "base-uri 'self'",
      "form-action 'self'"
    ].join('; ');
    
    return `Content-Security-Policy: ${cspPolicy}`;
  }

  // 5. è¾“å…¥éªŒè¯
  validateInput(input, type) {
    const validators = {
      email: /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
      url: /^https?:\/\/.+/,
      alphanumeric: /^[a-zA-Z0-9]+$/,
      phone: /^\+?[\d\s-()]+$/
    };
    
    if (!validators[type]) {
      throw new Error(`Unknown validation type: ${type}`);
    }
    
    return validators[type].test(input);
  }

  // 6. å®‰å…¨çš„JSONè§£æ
  safeJSONParse(jsonString) {
    try {
      // é˜²æ­¢åŸå‹æ±¡æŸ“
      return JSON.parse(jsonString, (key, value) => {
        if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
          return undefined;
        }
        return value;
      });
    } catch (error) {
      console.error('JSON parse error:', error);
      return null;
    }
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const xssProtection = new XSSProtection();

// ç”¨æˆ·è¾“å…¥å¤„ç†
const userInput = '<script>alert("XSS")</script>';
const safeInput = xssProtection.sanitizeInput(userInput);
console.log(safeInput); // &lt;script&gt;alert(&quot;XSS&quot;)&lt;/script&gt;
```

### Q2: ä»€ä¹ˆæ˜¯CSRFæ”»å‡»ï¼Ÿå¦‚ä½•é˜²æŠ¤ï¼Ÿ

**æ ‡å‡†ç­”æ¡ˆï¼š**
CSRFï¼ˆCross-Site Request Forgeryï¼‰æ˜¯è·¨ç«™è¯·æ±‚ä¼ªé€ æ”»å‡»ï¼Œåˆ©ç”¨ç”¨æˆ·å·²ç™»å½•çš„èº«ä»½æ‰§è¡Œæ¶æ„æ“ä½œã€‚

**é¢è¯•å›ç­”æŠ€å·§ï¼š**
```javascript
// CSRFé˜²æŠ¤æœºåˆ¶
class CSRFProtection {
  constructor() {
    this.tokenName = 'csrf-token';
    this.headerName = 'X-CSRF-Token';
  }

  // 1. ç”ŸæˆCSRF Token
  generateCSRFToken() {
    const array = new Uint8Array(32);
    crypto.getRandomValues(array);
    return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
  }

  // 2. è®¾ç½®CSRF Tokenåˆ°é¡µé¢
  setCSRFToken() {
    const token = this.generateCSRFToken();
    
    // è®¾ç½®åˆ°metaæ ‡ç­¾
    const metaTag = document.createElement('meta');
    metaTag.name = this.tokenName;
    metaTag.content = token;
    document.head.appendChild(metaTag);
    
    // è®¾ç½®åˆ°sessionStorage
    sessionStorage.setItem(this.tokenName, token);
    
    return token;
  }

  // 3. è·å–CSRF Token
  getCSRFToken() {
    // ä¼˜å…ˆä»metaæ ‡ç­¾è·å–
    const metaTag = document.querySelector(`meta[name="${this.tokenName}"]`);
    if (metaTag) {
      return metaTag.content;
    }
    
    // ä»sessionStorageè·å–
    return sessionStorage.getItem(this.tokenName);
  }

  // 4. å®‰å…¨çš„AJAXè¯·æ±‚
  secureAjax(url, options = {}) {
    const token = this.getCSRFToken();
    
    const defaultOptions = {
      credentials: 'same-origin', // åŒæºè¯·æ±‚æºå¸¦Cookie
      headers: {
        'Content-Type': 'application/json',
        [this.headerName]: token
      }
    };
    
    const mergedOptions = {
      ...defaultOptions,
      ...options,
      headers: {
        ...defaultOptions.headers,
        ...options.headers
      }
    };
    
    return fetch(url, mergedOptions);
  }

  // 5. è¡¨å•CSRFä¿æŠ¤
  protectForm(formElement) {
    const token = this.getCSRFToken();
    
    // æ·»åŠ éšè—çš„CSRF tokenå­—æ®µ
    const tokenInput = document.createElement('input');
    tokenInput.type = 'hidden';
    tokenInput.name = this.tokenName;
    tokenInput.value = token;
    
    formElement.appendChild(tokenInput);
  }

  // 6. SameSite Cookieè®¾ç½®
  setSameSiteCookie(name, value, options = {}) {
    const defaultOptions = {
      sameSite: 'Strict', // æˆ– 'Lax'
      secure: true, // HTTPSç¯å¢ƒ
      httpOnly: true // æœåŠ¡ç«¯è®¾ç½®
    };
    
    const cookieOptions = { ...defaultOptions, ...options };
    const optionsString = Object.entries(cookieOptions)
      .map(([key, value]) => `${key}=${value}`)
      .join('; ');
    
    document.cookie = `${name}=${value}; ${optionsString}`;
  }

  // 7. éªŒè¯Refererå¤´
  validateReferer(allowedOrigins) {
    const referer = document.referrer;
    if (!referer) return false;
    
    try {
      const refererOrigin = new URL(referer).origin;
      return allowedOrigins.includes(refererOrigin);
    } catch (error) {
      return false;
    }
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const csrfProtection = new CSRFProtection();

// é¡µé¢åŠ è½½æ—¶è®¾ç½®CSRF token
document.addEventListener('DOMContentLoaded', () => {
  csrfProtection.setCSRFToken();
  
  // ä¿æŠ¤æ‰€æœ‰è¡¨å•
  document.querySelectorAll('form').forEach(form => {
    csrfProtection.protectForm(form);
  });
});

// å®‰å…¨çš„APIè°ƒç”¨
csrfProtection.secureAjax('/api/user/update', {
  method: 'POST',
  body: JSON.stringify({ name: 'John' })
});
```

### Q3: å¦‚ä½•å®ç°å†…å®¹å®‰å…¨ç­–ç•¥(CSP)ï¼Ÿ

**æ ‡å‡†ç­”æ¡ˆï¼š**
CSPæ˜¯é€šè¿‡HTTPå¤´æˆ–metaæ ‡ç­¾è®¾ç½®çš„å®‰å…¨ç­–ç•¥ï¼Œç”¨äºé˜²æ­¢XSSã€æ•°æ®æ³¨å…¥ç­‰æ”»å‡»ã€‚

**é¢è¯•å›ç­”æŠ€å·§ï¼š**
```javascript
// CSPç­–ç•¥ç®¡ç†
class CSPManager {
  constructor() {
    this.policies = new Map();
    this.nonces = new Set();
  }

  // 1. ç”ŸæˆCSPç­–ç•¥
  generateCSPPolicy(config) {
    const directives = [];
    
    // é»˜è®¤ç­–ç•¥
    if (config.defaultSrc) {
      directives.push(`default-src ${config.defaultSrc.join(' ')}`);
    }
    
    // è„šæœ¬ç­–ç•¥
    if (config.scriptSrc) {
      const scriptSources = [...config.scriptSrc];
      
      // æ·»åŠ nonce
      if (config.useNonce) {
        const nonce = this.generateNonce();
        scriptSources.push(`'nonce-${nonce}'`);
      }
      
      directives.push(`script-src ${scriptSources.join(' ')}`);
    }
    
    // æ ·å¼ç­–ç•¥
    if (config.styleSrc) {
      directives.push(`style-src ${config.styleSrc.join(' ')}`);
    }
    
    // å›¾ç‰‡ç­–ç•¥
    if (config.imgSrc) {
      directives.push(`img-src ${config.imgSrc.join(' ')}`);
    }
    
    // è¿æ¥ç­–ç•¥
    if (config.connectSrc) {
      directives.push(`connect-src ${config.connectSrc.join(' ')}`);
    }
    
    // å­—ä½“ç­–ç•¥
    if (config.fontSrc) {
      directives.push(`font-src ${config.fontSrc.join(' ')}`);
    }
    
    // å¯¹è±¡ç­–ç•¥
    if (config.objectSrc !== undefined) {
      directives.push(`object-src ${config.objectSrc}`);
    }
    
    // åŸºç¡€URIç­–ç•¥
    if (config.baseUri) {
      directives.push(`base-uri ${config.baseUri.join(' ')}`);
    }
    
    // è¡¨å•actionç­–ç•¥
    if (config.formAction) {
      directives.push(`form-action ${config.formAction.join(' ')}`);
    }
    
    return directives.join('; ');
  }

  // 2. ç”Ÿæˆnonce
  generateNonce() {
    const array = new Uint8Array(16);
    crypto.getRandomValues(array);
    const nonce = btoa(String.fromCharCode(...array));
    this.nonces.add(nonce);
    return nonce;
  }

  // 3. è®¾ç½®CSPå¤´ï¼ˆæœåŠ¡ç«¯ï¼‰
  setCSPHeader(response, policy) {
    response.setHeader('Content-Security-Policy', policy);
    
    // åŒæ—¶è®¾ç½®æŠ¥å‘Šæ¨¡å¼ç”¨äºæµ‹è¯•
    response.setHeader('Content-Security-Policy-Report-Only', policy);
  }

  // 4. è®¾ç½®CSP metaæ ‡ç­¾ï¼ˆå®¢æˆ·ç«¯ï¼‰
  setCSPMeta(policy) {
    const existingMeta = document.querySelector('meta[http-equiv="Content-Security-Policy"]');
    if (existingMeta) {
      existingMeta.content = policy;
    } else {
      const meta = document.createElement('meta');
      meta.httpEquiv = 'Content-Security-Policy';
      meta.content = policy;
      document.head.appendChild(meta);
    }
  }

  // 5. åŠ¨æ€è„šæœ¬åŠ è½½ï¼ˆä½¿ç”¨nonceï¼‰
  loadScriptWithNonce(src, nonce) {
    const script = document.createElement('script');
    script.src = src;
    script.nonce = nonce;
    
    return new Promise((resolve, reject) => {
      script.onload = resolve;
      script.onerror = reject;
      document.head.appendChild(script);
    });
  }

  // 6. CSPè¿è§„æŠ¥å‘Šå¤„ç†
  handleCSPViolation() {
    document.addEventListener('securitypolicyviolation', (event) => {
      const violation = {
        blockedURI: event.blockedURI,
        violatedDirective: event.violatedDirective,
        originalPolicy: event.originalPolicy,
        sourceFile: event.sourceFile,
        lineNumber: event.lineNumber,
        columnNumber: event.columnNumber,
        timestamp: Date.now()
      };
      
      // å‘é€è¿è§„æŠ¥å‘Š
      this.reportViolation(violation);
    });
  }

  // 7. å‘é€è¿è§„æŠ¥å‘Š
  async reportViolation(violation) {
    try {
      await fetch('/api/csp-violation', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(violation)
      });
    } catch (error) {
      console.error('Failed to report CSP violation:', error);
    }
  }

  // 8. é¢„è®¾CSPé…ç½®
  getPresetConfigs() {
    return {
      strict: {
        defaultSrc: ["'self'"],
        scriptSrc: ["'self'"],
        styleSrc: ["'self'", "'unsafe-inline'"],
        imgSrc: ["'self'", "data:", "https:"],
        connectSrc: ["'self'"],
        fontSrc: ["'self'"],
        objectSrc: "'none'",
        baseUri: ["'self'"],
        formAction: ["'self'"],
        useNonce: true
      },
      
      moderate: {
        defaultSrc: ["'self'"],
        scriptSrc: ["'self'", "'unsafe-inline'", "https://trusted-cdn.com"],
        styleSrc: ["'self'", "'unsafe-inline'"],
        imgSrc: ["'self'", "data:", "https:"],
        connectSrc: ["'self'", "https://api.example.com"],
        fontSrc: ["'self'", "https://fonts.googleapis.com"],
        objectSrc: "'none'",
        baseUri: ["'self'"],
        formAction: ["'self'"]
      },
      
      development: {
        defaultSrc: ["'self'"],
        scriptSrc: ["'self'", "'unsafe-inline'", "'unsafe-eval'"],
        styleSrc: ["'self'", "'unsafe-inline'"],
        imgSrc: ["'self'", "data:", "https:", "http:"],
        connectSrc: ["'self'", "*"],
        fontSrc: ["'self'", "*"],
        objectSrc: "'none'",
        baseUri: ["'self'"],
        formAction: ["'self'"]
      }
    };
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const cspManager = new CSPManager();

// ç”Ÿæˆä¸¥æ ¼çš„CSPç­–ç•¥
const strictConfig = cspManager.getPresetConfigs().strict;
const cspPolicy = cspManager.generateCSPPolicy(strictConfig);

// è®¾ç½®CSP
cspManager.setCSPMeta(cspPolicy);

// å¤„ç†è¿è§„æŠ¥å‘Š
cspManager.handleCSPViolation();

// ä½¿ç”¨nonceåŠ è½½è„šæœ¬
const nonce = cspManager.generateNonce();
cspManager.loadScriptWithNonce('/js/analytics.js', nonce);
```

### Q4: å¦‚ä½•é˜²æŠ¤ç‚¹å‡»åŠ«æŒæ”»å‡»ï¼Ÿ

**æ ‡å‡†ç­”æ¡ˆï¼š**
ç‚¹å‡»åŠ«æŒé€šè¿‡iframeåµŒå¥—é¡µé¢ï¼Œè¯±å¯¼ç”¨æˆ·ç‚¹å‡»éšè—çš„æ¶æ„å†…å®¹ã€‚ä¸»è¦é˜²æŠ¤æ–¹æ³•æ˜¯X-Frame-Optionså’ŒCSPçš„frame-ancestorsã€‚

**é¢è¯•å›ç­”æŠ€å·§ï¼š**
```javascript
// ç‚¹å‡»åŠ«æŒé˜²æŠ¤
class ClickjackingProtection {
  constructor() {
    this.frameOptions = {
      DENY: 'DENY',
      SAMEORIGIN: 'SAMEORIGIN',
      ALLOW_FROM: 'ALLOW-FROM'
    };
  }

  // 1. è®¾ç½®X-Frame-Optionså¤´
  setFrameOptions(option, allowedOrigin = null) {
    let headerValue = option;
    
    if (option === this.frameOptions.ALLOW_FROM && allowedOrigin) {
      headerValue = `${option} ${allowedOrigin}`;
    }
    
    // æœåŠ¡ç«¯è®¾ç½®
    // response.setHeader('X-Frame-Options', headerValue);
    
    // å®¢æˆ·ç«¯æ£€æµ‹
    this.detectFraming();
    
    return headerValue;
  }

  // 2. ä½¿ç”¨CSP frame-ancestors
  setFrameAncestorsCSP(allowedOrigins = ["'self'"]) {
    const cspDirective = `frame-ancestors ${allowedOrigins.join(' ')}`;
    
    // æ·»åŠ åˆ°ç°æœ‰CSPæˆ–åˆ›å»ºæ–°çš„
    const existingCSP = document.querySelector('meta[http-equiv="Content-Security-Policy"]');
    if (existingCSP) {
      existingCSP.content += `; ${cspDirective}`;
    } else {
      const meta = document.createElement('meta');
      meta.httpEquiv = 'Content-Security-Policy';
      meta.content = cspDirective;
      document.head.appendChild(meta);
    }
  }

  // 3. JavaScript frame busting
  detectFraming() {
    if (window.top !== window.self) {
      // æ£€æµ‹æ˜¯å¦è¢«åµŒå…¥iframe
      this.handleFrameDetection();
    }
  }

  // 4. å¤„ç†frameæ£€æµ‹
  handleFrameDetection() {
    // æ–¹æ³•1: è·³å‡ºiframe
    if (window.top !== window.self) {
      window.top.location = window.location;
    }
    
    // æ–¹æ³•2: æ˜¾ç¤ºè­¦å‘Š
    this.showFramingWarning();
    
    // æ–¹æ³•3: é˜»æ­¢é¡µé¢æ˜¾ç¤º
    document.body.style.display = 'none';
  }

  // 5. æ˜¾ç¤ºåµŒå¥—è­¦å‘Š
  showFramingWarning() {
    const warning = document.createElement('div');
    warning.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255, 0, 0, 0.9);
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 999999;
      font-size: 24px;
      text-align: center;
    `;
    warning.innerHTML = `
      <div>
        <h2>å®‰å…¨è­¦å‘Š</h2>
        <p>æ­¤é¡µé¢ä¸å…è®¸åœ¨iframeä¸­æ˜¾ç¤º</p>
        <button onclick="window.top.location = window.location">
          åœ¨æ–°çª—å£ä¸­æ‰“å¼€
        </button>
      </div>
    `;
    
    document.body.appendChild(warning);
  }

  // 6. é«˜çº§frame busting
  advancedFrameBusting() {
    // é˜²æ­¢åµŒå¥—é¡µé¢ç¦ç”¨JavaScript
    const script = document.createElement('script');
    script.textContent = `
      (function() {
        if (window.top !== window.self) {
          var overlay = document.createElement('div');
          overlay.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:#fff;z-index:999999;';
          overlay.innerHTML = '<h1 style="text-align:center;margin-top:200px;">æ­¤é¡µé¢ä¸èƒ½åœ¨æ¡†æ¶ä¸­æ˜¾ç¤º</h1>';
          document.body.appendChild(overlay);
        }
      })();
    `;
    document.head.appendChild(script);
  }

  // 7. æ£€æµ‹æ²™ç®±iframe
  detectSandboxedFrame() {
    try {
      // å°è¯•è®¿é—®çˆ¶çª—å£
      const parentOrigin = window.parent.location.origin;
      return false; // å¦‚æœèƒ½è®¿é—®ï¼Œè¯´æ˜ä¸æ˜¯æ²™ç®±
    } catch (e) {
      // è¢«æ²™ç®±é™åˆ¶ï¼Œæ— æ³•è®¿é—®çˆ¶çª—å£
      return true;
    }
  }

  // 8. ç”¨æˆ·äº¤äº’éªŒè¯
  requireUserInteraction() {
    let userInteracted = false;
    
    const interactionEvents = ['click', 'keydown', 'touchstart'];
    
    interactionEvents.forEach(event => {
      document.addEventListener(event, () => {
        userInteracted = true;
      }, { once: true });
    });
    
    // å»¶è¿Ÿæ‰§è¡Œæ•æ„Ÿæ“ä½œ
    setTimeout(() => {
      if (!userInteracted) {
        console.warn('No user interaction detected, possible clickjacking');
        this.showFramingWarning();
      }
    }, 3000);
  }

  // 9. è§†è§‰æŒ‡ç¤ºå™¨
  addVisualIndicators() {
    // æ·»åŠ è¾¹æ¡†æŒ‡ç¤ºå™¨
    const indicator = document.createElement('div');
    indicator.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      border: 5px solid red;
      pointer-events: none;
      z-index: 999998;
      animation: blink 1s infinite;
    `;
    
    const style = document.createElement('style');
    style.textContent = `
      @keyframes blink {
        0%, 50% { opacity: 1; }
        51%, 100% { opacity: 0; }
      }
    `;
    
    document.head.appendChild(style);
    document.body.appendChild(indicator);
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const clickjackProtection = new ClickjackingProtection();

// è®¾ç½®frameä¿æŠ¤
clickjackProtection.setFrameOptions('SAMEORIGIN');
clickjackProtection.setFrameAncestorsCSP(["'self'", "https://trusted-site.com"]);

// å¯ç”¨é«˜çº§ä¿æŠ¤
clickjackProtection.advancedFrameBusting();
clickjackProtection.requireUserInteraction();

// å¼€å‘ç¯å¢ƒä¸‹æ˜¾ç¤ºè§†è§‰æŒ‡ç¤ºå™¨
if (process.env.NODE_ENV === 'development') {
  clickjackProtection.addVisualIndicators();
}
```

### Q5: å¦‚ä½•å®ç°å‰ç«¯æ•°æ®åŠ å¯†å’Œå®‰å…¨ä¼ è¾“ï¼Ÿ

**æ ‡å‡†ç­”æ¡ˆï¼š**
å‰ç«¯æ•°æ®åŠ å¯†åŒ…æ‹¬æ•æ„Ÿæ•°æ®åŠ å¯†ã€ä¼ è¾“åŠ å¯†ã€å­˜å‚¨åŠ å¯†ç­‰å¤šä¸ªå±‚é¢ã€‚

**é¢è¯•å›ç­”æŠ€å·§ï¼š**
```javascript
// å‰ç«¯åŠ å¯†å·¥å…·ç±»
class FrontendCrypto {
  constructor() {
    this.algorithm = 'AES-GCM';
    this.keyLength = 256;
  }

  // 1. ç”ŸæˆåŠ å¯†å¯†é’¥
  async generateKey() {
    return await crypto.subtle.generateKey(
      {
        name: this.algorithm,
        length: this.keyLength
      },
      true, // å¯å¯¼å‡º
      ['encrypt', 'decrypt']
    );
  }

  // 2. å¯¼å‡ºå¯†é’¥
  async exportKey(key) {
    const exported = await crypto.subtle.exportKey('jwk', key);
    return JSON.stringify(exported);
  }

  // 3. å¯¼å…¥å¯†é’¥
  async importKey(keyData) {
    const keyObject = JSON.parse(keyData);
    return await crypto.subtle.importKey(
      'jwk',
      keyObject,
      { name: this.algorithm },
      true,
      ['encrypt', 'decrypt']
    );
  }

  // 4. åŠ å¯†æ•°æ®
  async encrypt(data, key) {
    const encoder = new TextEncoder();
    const encodedData = encoder.encode(data);
    
    // ç”ŸæˆéšæœºIV
    const iv = crypto.getRandomValues(new Uint8Array(12));
    
    const encrypted = await crypto.subtle.encrypt(
      {
        name: this.algorithm,
        iv: iv
      },
      key,
      encodedData
    );
    
    // å°†IVå’ŒåŠ å¯†æ•°æ®ç»„åˆ
    const result = new Uint8Array(iv.length + encrypted.byteLength);
    result.set(iv);
    result.set(new Uint8Array(encrypted), iv.length);
    
    return btoa(String.fromCharCode(...result));
  }

  // 5. è§£å¯†æ•°æ®
  async decrypt(encryptedData, key) {
    const data = new Uint8Array(
      atob(encryptedData).split('').map(char => char.charCodeAt(0))
    );
    
    // æå–IVå’ŒåŠ å¯†æ•°æ®
    const iv = data.slice(0, 12);
    const encrypted = data.slice(12);
    
    const decrypted = await crypto.subtle.decrypt(
      {
        name: this.algorithm,
        iv: iv
      },
      key,
      encrypted
    );
    
    const decoder = new TextDecoder();
    return decoder.decode(decrypted);
  }

  // 6. å¯†ç å“ˆå¸Œ
  async hashPassword(password, salt = null) {
    if (!salt) {
      salt = crypto.getRandomValues(new Uint8Array(32));
    }
    
    const encoder = new TextEncoder();
    const passwordData = encoder.encode(password);
    
    // ä½¿ç”¨PBKDF2è¿›è¡Œå¯†ç å“ˆå¸Œ
    const key = await crypto.subtle.importKey(
      'raw',
      passwordData,
      { name: 'PBKDF2' },
      false,
      ['deriveBits']
    );
    
    const hashBuffer = await crypto.subtle.deriveBits(
      {
        name: 'PBKDF2',
        salt: salt,
        iterations: 100000,
        hash: 'SHA-256'
      },
      key,
      256
    );
    
    const hashArray = new Uint8Array(hashBuffer);
    const saltArray = new Uint8Array(salt);
    
    // ç»„åˆsaltå’Œhash
    const result = new Uint8Array(saltArray.length + hashArray.length);
    result.set(saltArray);
    result.set(hashArray, saltArray.length);
    
    return btoa(String.fromCharCode(...result));
  }

  // 7. éªŒè¯å¯†ç 
  async verifyPassword(password, hashedPassword) {
    const data = new Uint8Array(
      atob(hashedPassword).split('').map(char => char.charCodeAt(0))
    );
    
    const salt = data.slice(0, 32);
    const hash = data.slice(32);
    
    const newHash = await this.hashPassword(password, salt);
    return newHash === hashedPassword;
  }

  // 8. å®‰å…¨éšæœºæ•°ç”Ÿæˆ
  generateSecureRandom(length = 32) {
    const array = new Uint8Array(length);
    crypto.getRandomValues(array);
    return btoa(String.fromCharCode(...array));
  }

  // 9. æ•°å­—ç­¾å
  async generateKeyPair() {
    return await crypto.subtle.generateKey(
      {
        name: 'RSA-PSS',
        modulusLength: 2048,
        publicExponent: new Uint8Array([1, 0, 1]),
        hash: 'SHA-256'
      },
      true,
      ['sign', 'verify']
    );
  }

  async signData(data, privateKey) {
    const encoder = new TextEncoder();
    const encodedData = encoder.encode(data);
    
    const signature = await crypto.subtle.sign(
      {
        name: 'RSA-PSS',
        saltLength: 32
      },
      privateKey,
      encodedData
    );
    
    return btoa(String.fromCharCode(...new Uint8Array(signature)));
  }

  async verifySignature(data, signature, publicKey) {
    const encoder = new TextEncoder();
    const encodedData = encoder.encode(data);
    const signatureArray = new Uint8Array(
      atob(signature).split('').map(char => char.charCodeAt(0))
    );
    
    return await crypto.subtle.verify(
      {
        name: 'RSA-PSS',
        saltLength: 32
      },
      publicKey,
      signatureArray,
      encodedData
    );
  }
}

// å®‰å…¨å­˜å‚¨ç®¡ç†
class SecureStorage {
  constructor() {
    this.crypto = new FrontendCrypto();
    this.keyName = 'secure-storage-key';
  }

  // åˆå§‹åŒ–åŠ å¯†å­˜å‚¨
  async init() {
    let key = localStorage.getItem(this.keyName);
    if (!key) {
      const cryptoKey = await this.crypto.generateKey();
      key = await this.crypto.exportKey(cryptoKey);
      localStorage.setItem(this.keyName, key);
    }
    this.key = await this.crypto.importKey(key);
  }

  // å®‰å…¨å­˜å‚¨æ•°æ®
  async setItem(name, value) {
    if (!this.key) await this.init();
    
    const encryptedValue = await this.crypto.encrypt(
      JSON.stringify(value),
      this.key
    );
    localStorage.setItem(name, encryptedValue);
  }

  // å®‰å…¨è·å–æ•°æ®
  async getItem(name) {
    if (!this.key) await this.init();
    
    const encryptedValue = localStorage.getItem(name);
    if (!encryptedValue) return null;
    
    try {
      const decryptedValue = await this.crypto.decrypt(encryptedValue, this.key);
      return JSON.parse(decryptedValue);
    } catch (error) {
      console.error('Failed to decrypt stored data:', error);
      return null;
    }
  }

  // æ¸…ç†æ•æ„Ÿæ•°æ®
  clear() {
    localStorage.removeItem(this.keyName);
    this.key = null;
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const secureStorage = new SecureStorage();

// å­˜å‚¨æ•æ„Ÿæ•°æ®
await secureStorage.setItem('user-token', 'sensitive-jwt-token');

// è·å–æ•æ„Ÿæ•°æ®
const token = await secureStorage.getItem('user-token');

// å¯†ç å¤„ç†
const crypto = new FrontendCrypto();
const hashedPassword = await crypto.hashPassword('user-password');
const isValid = await crypto.verifyPassword('user-password', hashedPassword);
```

## ğŸ¯ é¢è¯•æŠ€å·§æ€»ç»“

### å›ç­”ç­–ç•¥

**1. å®‰å…¨æ„è¯†**
- å±•ç¤ºå¯¹å‰ç«¯å®‰å…¨å¨èƒçš„å…¨é¢ç†è§£
- è¯´æ˜é˜²æŠ¤æªæ–½çš„é‡è¦æ€§å’Œå¿…è¦æ€§

**2. æŠ€æœ¯æ·±åº¦**
- æŒæ¡å„ç§æ”»å‡»åŸç†å’Œé˜²æŠ¤æœºåˆ¶
- èƒ½å¤Ÿå®ç°å…·ä½“çš„å®‰å…¨é˜²æŠ¤ä»£ç 

**3. å®è·µç»éªŒ**
- ç»“åˆå®é™…é¡¹ç›®ä¸­çš„å®‰å…¨å®è·µ
- åˆ†äº«å®‰å…¨é—®é¢˜çš„å‘ç°å’Œè§£å†³è¿‡ç¨‹

### åŠ åˆ†ç‚¹

1. **å…¨é¢æ€§**ï¼šæ¶µç›–XSSã€CSRFã€ç‚¹å‡»åŠ«æŒç­‰å¤šç§æ”»å‡»
2. **æ·±åº¦ç†è§£**ï¼šç†è§£æ”»å‡»åŸç†å’Œé˜²æŠ¤æœºåˆ¶
3. **å®ç”¨æ€§**ï¼šæä¾›å¯ç›´æ¥ä½¿ç”¨çš„é˜²æŠ¤ä»£ç 
4. **å‰ç»æ€§**ï¼šäº†è§£æ–°å…´çš„å®‰å…¨å¨èƒå’Œé˜²æŠ¤æŠ€æœ¯

### å¸¸è§è¯¯åŒº

1. **åªçŸ¥é˜²æŠ¤ä¸çŸ¥åŸç†**ï¼šè¦ç†è§£æ”»å‡»çš„å·¥ä½œåŸç†
2. **å¿½è§†ç”¨æˆ·ä½“éªŒ**ï¼šå®‰å…¨æªæ–½ä¸èƒ½ä¸¥é‡å½±å“ç”¨æˆ·ä½“éªŒ
3. **è¿‡åº¦ä¾èµ–å·¥å…·**ï¼šè¦ç†è§£å·¥å…·èƒŒåçš„åŸç†
4. **ç¼ºä¹å®è·µéªŒè¯**ï¼šè¦åœ¨å®é™…é¡¹ç›®ä¸­éªŒè¯é˜²æŠ¤æ•ˆæœ

### é¢è¯•å‡†å¤‡æ¸…å•

- [ ] ç†è§£å„ç§å‰ç«¯å®‰å…¨å¨èƒå’Œæ”»å‡»åŸç†
- [ ] æŒæ¡XSSã€CSRFã€ç‚¹å‡»åŠ«æŒçš„é˜²æŠ¤æ–¹æ³•
- [ ] äº†è§£CSPçš„é…ç½®å’Œä½¿ç”¨
- [ ] æŒæ¡å‰ç«¯åŠ å¯†å’Œå®‰å…¨ä¼ è¾“æŠ€æœ¯
- [ ] å‡†å¤‡å®é™…çš„å®‰å…¨é˜²æŠ¤æ¡ˆä¾‹
- [ ] äº†è§£å®‰å…¨å®¡è®¡å’Œæ¼æ´æ‰«æå·¥å…·

## ğŸ’¡ æ€»ç»“

å‰ç«¯å®‰å…¨é˜²æŠ¤ä¸»è¦åŒ…æ‹¬ï¼š
1. **è¾“å…¥éªŒè¯**ï¼šé˜²æ­¢æ¶æ„è„šæœ¬æ³¨å…¥
2. **è¾“å‡ºç¼–ç **ï¼šå®‰å…¨åœ°æ˜¾ç¤ºç”¨æˆ·æ•°æ®
3. **è®¿é—®æ§åˆ¶**ï¼šé˜²æ­¢æœªæˆæƒæ“ä½œ
4. **ä¼ è¾“å®‰å…¨**ï¼šä¿æŠ¤æ•°æ®ä¼ è¾“è¿‡ç¨‹
5. **å­˜å‚¨å®‰å…¨**ï¼šä¿æŠ¤æœ¬åœ°å­˜å‚¨çš„æ•æ„Ÿæ•°æ®

é¢è¯•æ—¶è¦é‡ç‚¹å±•ç¤ºï¼š
- å¯¹å‰ç«¯å®‰å…¨å¨èƒçš„æ·±å…¥ç†è§£
- å®é™…çš„å®‰å…¨é˜²æŠ¤å®ç°èƒ½åŠ›
- å®‰å…¨ä¸ç”¨æˆ·ä½“éªŒçš„å¹³è¡¡è€ƒè™‘
- æŒç»­çš„å®‰å…¨æ„è¯†å’Œå­¦ä¹ èƒ½åŠ› 