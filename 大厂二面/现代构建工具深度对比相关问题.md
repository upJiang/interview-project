# 现代构建工具深度对比相关问题 - 前端面试指南

## 📋 常见面试题与答案

### Q1: Webpack、Vite、Rollup的核心差异是什么？

**标准答案：**
三者都是现代前端构建工具，但在构建策略、开发体验、打包优化等方面有显著差异。

**面试回答技巧：**
```javascript
// 构建工具核心差异对比
const BuildToolsComparison = {
  webpack: {
    核心理念: "一切皆模块，通过loader和plugin处理各种资源",
    构建方式: "Bundle-based，将所有模块打包成少数几个文件",
    开发服务器: "webpack-dev-server，热更新基于内存文件系统",
    配置复杂度: "高，需要详细配置loader、plugin、optimization等",
    
    优势: [
      "生态最成熟，插件和loader丰富",
      "支持各种复杂场景和优化策略",
      "代码分割和懒加载支持完善",
      "HMR（热模块替换）功能强大"
    ],
    
    劣势: [
      "配置复杂，学习成本高",
      "冷启动速度慢，特别是大型项目",
      "构建速度相对较慢"
    ],
    
    适用场景: [
      "大型复杂项目",
      "需要高度定制化的构建流程",
      "对兼容性要求高的项目",
      "已有webpack生态的项目"
    ]
  },

  vite: {
    核心理念: "基于ESM的快速开发构建工具",
    构建方式: "开发时基于ESM，生产时使用Rollup打包",
    开发服务器: "基于ESM的dev server，按需编译",
    配置复杂度: "低，约定大于配置，开箱即用",
    
    优势: [
      "开发启动速度极快",
      "热更新速度快，只更新变化的模块",
      "配置简单，开箱即用",
      "原生支持TypeScript、JSX等"
    ],
    
    劣势: [
      "生态相对较新，插件不如webpack丰富",
      "对老旧浏览器支持需要额外配置",
      "某些复杂场景可能需要额外处理"
    ],
    
    适用场景: [
      "现代前端项目（Vue 3、React等）",
      "追求开发体验的项目",
      "中小型到中大型项目",
      "原型开发和快速迭代"
    ]
  },

  rollup: {
    核心理念: "专注于ES模块的高效打包工具",
    构建方式: "Tree-shaking优先，生成精简的ES模块输出",
    开发服务器: "通常配合其他工具使用",
    配置复杂度: "中等，专注于打包配置",
    
    优势: [
      "Tree-shaking效果最佳",
      "输出代码简洁，适合库开发",
      "支持多种输出格式（UMD、CJS、ESM等）",
      "构建速度快"
    ],
    
    劣势: [
      "主要面向库开发，应用开发功能有限",
      "开发服务器功能较弱",
      "处理复杂资源（图片、CSS等）需要额外配置"
    ],
    
    适用场景: [
      "JavaScript库和组件库开发",
      "需要多种输出格式的项目",
      "对包体积要求极高的项目",
      "作为其他工具的底层打包器"
    ]
  }
};
```

### Q2: 如何优化Webpack构建性能？

**标准答案：**
Webpack性能优化包括构建速度优化和打包体积优化两个方面。

**面试回答技巧：**
```javascript
// Webpack性能优化配置
class WebpackOptimization {
  // 1. 构建速度优化
  getBuildSpeedOptimizations() {
    return {
      // 使用更快的source-map
      devtool: 'eval-cheap-module-source-map', // 开发环境
      // devtool: 'source-map', // 生产环境
      
      // 缓存配置
      cache: {
        type: 'filesystem',
        cacheDirectory: path.resolve(__dirname, '.webpack_cache'),
        buildDependencies: {
          config: [__filename]
        }
      },
      
      // 多进程构建
      module: {
        rules: [
          {
            test: /\.js$/,
            use: [
              {
                loader: 'thread-loader',
                options: {
                  workers: require('os').cpus().length - 1
                }
              },
              'babel-loader'
            ],
            exclude: /node_modules/
          }
        ]
      },
      
      // 优化解析
      resolve: {
        // 减少解析步骤
        modules: [path.resolve(__dirname, 'src'), 'node_modules'],
        // 指定扩展名顺序
        extensions: ['.js', '.jsx', '.ts', '.tsx', '.json'],
        // 别名配置
        alias: {
          '@': path.resolve(__dirname, 'src'),
          'react': path.resolve(__dirname, 'node_modules/react')
        },
        // 优化模块解析
        symlinks: false
      },
      
      // 忽略不必要的文件
      module: {
        noParse: /jquery|lodash/, // 跳过没有依赖的库
      },
      
      // 外部依赖
      externals: {
        react: 'React',
        'react-dom': 'ReactDOM'
      }
    };
  }

  // 2. 打包体积优化
  getBundleSizeOptimizations() {
    return {
      optimization: {
        // 代码分割
        splitChunks: {
          chunks: 'all',
          cacheGroups: {
            // 第三方库单独打包
            vendor: {
              test: /[\\/]node_modules[\\/]/,
              name: 'vendors',
              chunks: 'all',
              priority: 10
            },
            // 公共代码提取
            common: {
              name: 'common',
              minChunks: 2,
              chunks: 'all',
              priority: 5,
              reuseExistingChunk: true
            }
          }
        },
        
        // 压缩配置
        minimize: true,
        minimizer: [
          new TerserPlugin({
            terserOptions: {
              compress: {
                drop_console: true, // 移除console
                drop_debugger: true, // 移除debugger
                pure_funcs: ['console.log'] // 移除特定函数
              },
              mangle: {
                safari10: true // 解决Safari 10的bug
              }
            },
            extractComments: false // 不提取注释到单独文件
          }),
          new CssMinimizerPlugin()
        ],
        
        // 运行时代码优化
        runtimeChunk: {
          name: 'runtime'
        }
      },
      
      // 插件优化
      plugins: [
        // 分析打包结果
        new BundleAnalyzerPlugin({
          analyzerMode: process.env.ANALYZE ? 'server' : 'disabled'
        }),
        
        // 压缩CSS
        new MiniCssExtractPlugin({
          filename: 'css/[name].[contenthash:8].css',
          chunkFilename: 'css/[name].[contenthash:8].chunk.css'
        }),
        
        // 压缩图片
        new ImageMinimizerPlugin({
          minimizer: {
            implementation: ImageMinimizerPlugin.imageminMinify,
            options: {
              plugins: [
                ['imagemin-mozjpeg', { quality: 80 }],
                ['imagemin-pngquant', { quality: [0.6, 0.8] }]
              ]
            }
          }
        })
      ]
    };
  }

  // 3. 开发环境优化
  getDevOptimizations() {
    return {
      devServer: {
        // 热更新
        hot: true,
        // 启用gzip压缩
        compress: true,
        // 减少日志输出
        stats: 'errors-warnings',
        // 客户端日志级别
        client: {
          logging: 'warn'
        }
      },
      
      // 优化重新构建速度
      watchOptions: {
        ignored: /node_modules/,
        aggregateTimeout: 300,
        poll: false
      }
    };
  }

  // 4. Tree Shaking优化
  getTreeShakingConfig() {
    return {
      mode: 'production',
      optimization: {
        usedExports: true,
        sideEffects: false // 标记无副作用
      },
      
      // 配置babel不转换ES模块
      module: {
        rules: [
          {
            test: /\.js$/,
            use: {
              loader: 'babel-loader',
              options: {
                presets: [
                  ['@babel/preset-env', {
                    modules: false // 保持ES模块格式
                  }]
                ]
              }
            }
          }
        ]
      }
    };
  }

  // 5. 完整的优化配置示例
  getOptimizedConfig() {
    return {
      ...this.getBuildSpeedOptimizations(),
      ...this.getBundleSizeOptimizations(),
      ...this.getDevOptimizations(),
      ...this.getTreeShakingConfig(),
      
      // 性能预算
      performance: {
        hints: 'warning',
        maxEntrypointSize: 512000, // 512KB
        maxAssetSize: 512000
      }
    };
  }
}

// 使用示例
const webpackOptimizer = new WebpackOptimization();
const optimizedConfig = webpackOptimizer.getOptimizedConfig();
```

### Q3: Vite的工作原理是什么？如何配置和优化？

**标准答案：**
Vite基于ESM和esbuild，开发时利用浏览器原生ES模块支持，生产时使用Rollup打包。

**面试回答技巧：**
```javascript
// Vite配置和优化
import { defineConfig } from 'vite';
import { resolve } from 'path';
import vue from '@vitejs/plugin-vue';
import { createHtmlPlugin } from 'vite-plugin-html';

class ViteOptimization {
  // 1. 基础配置
  getBaseConfig() {
    return defineConfig({
      // 根目录
      root: process.cwd(),
      
      // 基础路径
      base: process.env.NODE_ENV === 'production' ? '/my-app/' : '/',
      
      // 环境变量
      envPrefix: 'VITE_',
      
      // 路径别名
      resolve: {
        alias: {
          '@': resolve(__dirname, 'src'),
          '@components': resolve(__dirname, 'src/components'),
          '@utils': resolve(__dirname, 'src/utils')
        }
      },
      
      // CSS配置
      css: {
        preprocessorOptions: {
          scss: {
            additionalData: `@import "@/styles/variables.scss";`
          }
        },
        modules: {
          localsConvention: 'camelCase'
        }
      }
    });
  }

  // 2. 开发环境配置
  getDevConfig() {
    return {
      server: {
        // 端口
        port: 3000,
        // 自动打开浏览器
        open: true,
        // 热更新
        hmr: {
          overlay: true
        },
        // 代理配置
        proxy: {
          '/api': {
            target: 'http://localhost:8080',
            changeOrigin: true,
            rewrite: (path) => path.replace(/^\/api/, '')
          }
        },
        // CORS
        cors: true
      },
      
      // 依赖预构建
      optimizeDeps: {
        // 强制预构建的依赖
        include: ['lodash-es', 'axios'],
        // 排除预构建的依赖
        exclude: ['@vueuse/core']
      }
    };
  }

  // 3. 生产环境配置
  getProdConfig() {
    return {
      build: {
        // 输出目录
        outDir: 'dist',
        // 静态资源目录
        assetsDir: 'assets',
        // 清空输出目录
        emptyOutDir: true,
        
        // 代码分割
        rollupOptions: {
          output: {
            // 手动分包
            manualChunks: {
              'vue-vendor': ['vue', 'vue-router'],
              'ui-vendor': ['element-plus'],
              'utils-vendor': ['lodash-es', 'dayjs']
            },
            // 文件命名
            chunkFileNames: 'js/[name]-[hash].js',
            entryFileNames: 'js/[name]-[hash].js',
            assetFileNames: (assetInfo) => {
              const info = assetInfo.name.split('.');
              const ext = info[info.length - 1];
              if (/\.(mp4|webm|ogg|mp3|wav|flac|aac)$/.test(assetInfo.name)) {
                return `media/[name]-[hash].${ext}`;
              }
              if (/\.(png|jpe?g|gif|svg)$/.test(assetInfo.name)) {
                return `images/[name]-[hash].${ext}`;
              }
              if (ext === 'css') {
                return `css/[name]-[hash].${ext}`;
              }
              return `assets/[name]-[hash].${ext}`;
            }
          }
        },
        
        // 压缩配置
        minify: 'esbuild',
        
        // 生成source map
        sourcemap: process.env.NODE_ENV === 'development',
        
        // 资源内联阈值
        assetsInlineLimit: 4096,
        
        // CSS代码分割
        cssCodeSplit: true,
        
        // 构建报告
        reportCompressedSize: false
      }
    };
  }

  // 4. 插件配置
  getPluginsConfig() {
    return [
      // Vue支持
      vue(),
      
      // HTML模板
      createHtmlPlugin({
        minify: true,
        inject: {
          data: {
            title: 'My Vite App'
          }
        }
      }),
      
      // 自动导入
      AutoImport({
        imports: ['vue', 'vue-router'],
        dts: true
      }),
      
      // 组件自动导入
      Components({
        dts: true
      }),
      
      // PWA
      VitePWA({
        registerType: 'autoUpdate',
        workbox: {
          globPatterns: ['**/*.{js,css,html,ico,png,svg}']
        }
      }),
      
      // 打包分析
      process.env.ANALYZE && bundleAnalyzer()
    ];
  }

  // 5. 性能优化配置
  getPerformanceConfig() {
    return {
      // esbuild优化
      esbuild: {
        // 移除console和debugger
        drop: process.env.NODE_ENV === 'production' ? ['console', 'debugger'] : [],
        // 压缩标识符
        minifyIdentifiers: true,
        // 压缩语法
        minifySyntax: true,
        // 压缩空白
        minifyWhitespace: true
      },
      
      // 实验性功能
      experimental: {
        // 构建优化
        buildAdvancedBaseOptions: true
      },
      
      // 依赖优化
      optimizeDeps: {
        // 使用esbuild进行依赖预构建
        esbuildOptions: {
          target: 'es2020'
        }
      }
    };
  }

  // 6. 完整配置
  getCompleteConfig() {
    return defineConfig(({ command, mode }) => {
      const isProduction = mode === 'production';
      
      return {
        ...this.getBaseConfig(),
        ...(isProduction ? this.getProdConfig() : this.getDevConfig()),
        ...this.getPerformanceConfig(),
        
        plugins: this.getPluginsConfig(),
        
        // 环境变量类型定义
        define: {
          __VUE_OPTIONS_API__: true,
          __VUE_PROD_DEVTOOLS__: false
        }
      };
    });
  }
}

// Vite工作原理说明
const ViteWorkingPrinciple = {
  开发阶段: {
    模块解析: "利用浏览器原生ESM支持，按需加载模块",
    编译策略: "只编译当前页面需要的模块，实现快速冷启动",
    热更新: "基于ESM的精确热更新，只更新变化的模块",
    预构建: "使用esbuild预构建node_modules中的依赖"
  },
  
  生产阶段: {
    打包工具: "使用Rollup进行生产构建",
    优化策略: "Tree-shaking、代码分割、资源优化",
    兼容性: "通过@vitejs/plugin-legacy支持老旧浏览器"
  }
};

// 使用示例
const viteOptimizer = new ViteOptimization();
export default viteOptimizer.getCompleteConfig();
```

### Q4: 如何选择合适的构建工具？

**标准答案：**
选择构建工具需要考虑项目规模、团队技术栈、性能要求、维护成本等多个因素。

**面试回答技巧：**
```javascript
// 构建工具选择决策树
class BuildToolSelector {
  // 1. 项目评估维度
  evaluateProject(projectInfo) {
    const {
      size,           // 项目规模：small, medium, large
      team,           // 团队规模：1-5, 6-20, 20+
      framework,      // 框架：react, vue, angular, vanilla
      legacy,         // 是否需要支持老旧浏览器
      performance,    // 性能要求：low, medium, high
      maintenance,    // 维护成本考虑：low, medium, high
      timeline        // 开发周期：short, medium, long
    } = projectInfo;

    return {
      webpack: this.evaluateWebpack(projectInfo),
      vite: this.evaluateVite(projectInfo),
      rollup: this.evaluateRollup(projectInfo),
      parcel: this.evaluateParcel(projectInfo)
    };
  }

  // 2. Webpack适用性评估
  evaluateWebpack(project) {
    let score = 0;
    const reasons = [];

    // 项目规模加分
    if (project.size === 'large') {
      score += 30;
      reasons.push('大型项目，webpack生态完善');
    }

    // 复杂配置需求
    if (project.complexity === 'high') {
      score += 25;
      reasons.push('复杂构建需求，webpack可定制性强');
    }

    // 团队经验
    if (project.webpackExperience) {
      score += 20;
      reasons.push('团队有webpack经验');
    }

    // 老旧浏览器支持
    if (project.legacy) {
      score += 15;
      reasons.push('需要支持老旧浏览器');
    }

    // 微前端架构
    if (project.microfrontend) {
      score += 20;
      reasons.push('微前端场景，Module Federation支持');
    }

    return { score, reasons };
  }

  // 3. Vite适用性评估
  evaluateVite(project) {
    let score = 0;
    const reasons = [];

    // 现代框架
    if (['vue', 'react'].includes(project.framework)) {
      score += 25;
      reasons.push('现代框架，Vite支持良好');
    }

    // 开发体验要求
    if (project.devExperience === 'high') {
      score += 30;
      reasons.push('追求极致开发体验');
    }

    // 项目规模
    if (['small', 'medium'].includes(project.size)) {
      score += 20;
      reasons.push('中小型项目，配置简单');
    }

    // 现代浏览器
    if (!project.legacy) {
      score += 15;
      reasons.push('主要面向现代浏览器');
    }

    // 快速原型
    if (project.timeline === 'short') {
      score += 20;
      reasons.push('快速开发和原型验证');
    }

    return { score, reasons };
  }

  // 4. Rollup适用性评估
  evaluateRollup(project) {
    let score = 0;
    const reasons = [];

    // 库开发
    if (project.type === 'library') {
      score += 40;
      reasons.push('专为库开发设计');
    }

    // 包体积要求
    if (project.bundleSize === 'critical') {
      score += 25;
      reasons.push('极致的Tree-shaking和包体积优化');
    }

    // 多格式输出
    if (project.multipleFormats) {
      score += 20;
      reasons.push('需要多种输出格式（UMD、CJS、ESM）');
    }

    return { score, reasons };
  }

  // 5. 选择建议
  getRecommendation(projectInfo) {
    const evaluations = this.evaluateProject(projectInfo);
    
    // 找到最高分的工具
    const bestTool = Object.entries(evaluations)
      .sort(([,a], [,b]) => b.score - a.score)[0];

    const [toolName, evaluation] = bestTool;

    return {
      recommended: toolName,
      score: evaluation.score,
      reasons: evaluation.reasons,
      alternatives: this.getAlternatives(evaluations, toolName)
    };
  }

  // 6. 备选方案
  getAlternatives(evaluations, recommended) {
    return Object.entries(evaluations)
      .filter(([name]) => name !== recommended)
      .sort(([,a], [,b]) => b.score - a.score)
      .slice(0, 2)
      .map(([name, eval]) => ({
        name,
        score: eval.score,
        reasons: eval.reasons.slice(0, 2)
      }));
  }

  // 7. 迁移建议
  getMigrationAdvice(from, to) {
    const migrations = {
      'webpack-to-vite': {
        difficulty: 'medium',
        steps: [
          '分析webpack配置，识别关键插件',
          '安装Vite和相应插件',
          '创建vite.config.js配置文件',
          '调整入口文件和HTML模板',
          '处理环境变量和别名',
          '测试和调试构建结果'
        ],
        risks: [
          '某些webpack插件可能没有Vite等价物',
          '构建输出可能有差异',
          '需要更新CI/CD配置'
        ]
      },
      
      'webpack-to-rollup': {
        difficulty: 'high',
        steps: [
          '确认项目适合Rollup（主要是库项目）',
          '重新设计构建配置',
          '处理CSS和静态资源',
          '配置多格式输出',
          '设置开发环境'
        ],
        risks: [
          'Rollup主要面向库开发',
          '应用开发功能有限',
          '需要额外工具支持'
        ]
      }
    };

    return migrations[`${from}-to-${to}`] || {
      difficulty: 'unknown',
      message: '需要具体分析迁移路径'
    };
  }
}

// 使用示例
const selector = new BuildToolSelector();

// 项目信息
const projectInfo = {
  size: 'medium',
  team: 10,
  framework: 'react',
  legacy: false,
  performance: 'high',
  devExperience: 'high',
  timeline: 'medium',
  type: 'application'
};

// 获取推荐
const recommendation = selector.getRecommendation(projectInfo);
console.log('推荐构建工具:', recommendation);

// 迁移建议
const migrationAdvice = selector.getMigrationAdvice('webpack', 'vite');
console.log('迁移建议:', migrationAdvice);
```

### Q5: 如何实现构建工具的自定义插件？

**标准答案：**
不同构建工具的插件机制各有特点，需要理解其钩子系统和API设计。

**面试回答技巧：**
```javascript
// 1. Webpack插件开发
class WebpackCustomPlugin {
  constructor(options = {}) {
    this.options = options;
  }

  apply(compiler) {
    const pluginName = 'WebpackCustomPlugin';

    // 编译开始时
    compiler.hooks.compile.tap(pluginName, (compilationParams) => {
      console.log('编译开始...');
    });

    // 编译完成时
    compiler.hooks.compilation.tap(pluginName, (compilation) => {
      // 资源处理钩子
      compilation.hooks.processAssets.tap(
        {
          name: pluginName,
          stage: compilation.PROCESS_ASSETS_STAGE_OPTIMIZE
        },
        (assets) => {
          // 处理资源
          Object.keys(assets).forEach(filename => {
            if (filename.endsWith('.js')) {
              const asset = assets[filename];
              const source = asset.source();
              
              // 自定义处理逻辑
              const processedSource = this.processJavaScript(source);
              
              // 更新资源
              assets[filename] = {
                source: () => processedSource,
                size: () => processedSource.length
              };
            }
          });
        }
      );
    });

    // 构建完成时
    compiler.hooks.done.tap(pluginName, (stats) => {
      console.log('构建完成!');
      
      // 生成构建报告
      if (this.options.generateReport) {
        this.generateBuildReport(stats);
      }
    });
  }

  processJavaScript(source) {
    // 示例：添加版本信息
    const version = this.options.version || '1.0.0';
    return `/* Version: ${version} */\n${source}`;
  }

  generateBuildReport(stats) {
    const report = {
      buildTime: stats.endTime - stats.startTime,
      assets: stats.compilation.assets,
      errors: stats.compilation.errors,
      warnings: stats.compilation.warnings
    };
    
    require('fs').writeFileSync(
      'build-report.json',
      JSON.stringify(report, null, 2)
    );
  }
}

// 2. Vite插件开发
function viteCustomPlugin(options = {}) {
  return {
    name: 'vite-custom-plugin',
    
    // 配置解析钩子
    config(config, { command }) {
      if (command === 'serve') {
        // 开发环境配置
        config.define = config.define || {};
        config.define.__DEV__ = true;
      }
    },

    // 构建开始钩子
    buildStart(opts) {
      console.log('Vite构建开始...');
    },

    // 模块解析钩子
    resolveId(id, importer) {
      if (id === 'virtual:my-module') {
        return id;
      }
    },

    // 模块加载钩子
    load(id) {
      if (id === 'virtual:my-module') {
        return `export const msg = "Hello from virtual module!";`;
      }
    },

    // 模块转换钩子
    transform(code, id) {
      if (id.endsWith('.vue')) {
        // 处理Vue文件
        return {
          code: this.processVueFile(code),
          map: null
        };
      }
    },

    // 生成bundle钩子
    generateBundle(options, bundle) {
      // 生成额外文件
      this.emitFile({
        type: 'asset',
        fileName: 'manifest.json',
        source: JSON.stringify({
          version: options.version,
          buildTime: new Date().toISOString()
        })
      });
    },

    // 开发服务器钩子
    configureServer(server) {
      server.middlewares.use('/api/custom', (req, res, next) => {
        res.setHeader('Content-Type', 'application/json');
        res.end(JSON.stringify({ message: 'Custom API endpoint' }));
      });
    },

    processVueFile(code) {
      // 自定义Vue文件处理逻辑
      return code.replace(
        /<template>/g,
        '<template>\n  <!-- Processed by custom plugin -->'
      );
    }
  };
}

// 3. Rollup插件开发
function rollupCustomPlugin(options = {}) {
  return {
    name: 'rollup-custom-plugin',

    // 构建开始
    buildStart(opts) {
      console.log('Rollup构建开始...');
    },

    // 模块解析
    resolveId(id, importer) {
      if (id.startsWith('custom:')) {
        return id;
      }
      return null;
    },

    // 模块加载
    load(id) {
      if (id.startsWith('custom:')) {
        const moduleName = id.replace('custom:', '');
        return `export default "${moduleName} module content";`;
      }
      return null;
    },

    // 代码转换
    transform(code, id) {
      if (options.transformJS && id.endsWith('.js')) {
        return {
          code: this.transformJavaScript(code),
          map: null
        };
      }
    },

    // 生成输出
    generateBundle(opts, bundle) {
      // 添加自定义文件到输出
      this.emitFile({
        type: 'asset',
        fileName: 'custom-info.txt',
        source: `Build completed at: ${new Date().toISOString()}`
      });
    },

    // 写入文件前
    writeBundle(opts, bundle) {
      console.log(`输出到: ${opts.dir || opts.file}`);
    },

    transformJavaScript(code) {
      // 示例转换：添加严格模式
      if (!code.includes('use strict')) {
        return `'use strict';\n${code}`;
      }
      return code;
    }
  };
}

// 4. 通用插件工具类
class PluginUtils {
  // 文件处理工具
  static processFile(content, transforms = []) {
    return transforms.reduce((result, transform) => {
      return transform(result);
    }, content);
  }

  // 资源优化工具
  static optimizeAsset(content, type) {
    switch (type) {
      case 'js':
        return this.minifyJS(content);
      case 'css':
        return this.minifyCSS(content);
      default:
        return content;
    }
  }

  static minifyJS(content) {
    // 简单的JS压缩示例
    return content
      .replace(/\s+/g, ' ')
      .replace(/;\s*}/g, '}')
      .trim();
  }

  static minifyCSS(content) {
    // 简单的CSS压缩示例
    return content
      .replace(/\s+/g, ' ')
      .replace(/;\s*}/g, '}')
      .replace(/,\s+/g, ',')
      .trim();
  }

  // 生成哈希
  static generateHash(content, length = 8) {
    const crypto = require('crypto');
    return crypto
      .createHash('md5')
      .update(content)
      .digest('hex')
      .slice(0, length);
  }
}

// 使用示例
module.exports = {
  // Webpack配置
  plugins: [
    new WebpackCustomPlugin({
      version: '1.0.0',
      generateReport: true
    })
  ],

  // Vite配置中使用
  // plugins: [viteCustomPlugin({ transformVue: true })],

  // Rollup配置中使用
  // plugins: [rollupCustomPlugin({ transformJS: true })]
};
```

## 🎯 面试技巧总结

### 回答策略

**1. 技术对比**
- 清楚说明各构建工具的核心差异
- 结合具体场景分析优劣

**2. 实践经验**
- 展示实际的配置和优化经验
- 分享性能优化的具体措施

**3. 深度理解**
- 理解构建工具的工作原理
- 掌握插件开发和自定义配置

### 加分点

1. **全面对比**：能够客观分析各工具的优劣
2. **性能优化**：掌握具体的优化策略和配置
3. **插件开发**：有自定义插件开发经验
4. **迁移经验**：有构建工具迁移的实践经验

### 常见误区

1. **盲目追新**：不结合项目实际选择工具
2. **配置过度**：过度优化导致配置复杂
3. **忽视维护**：不考虑长期维护成本
4. **缺乏实践**：只了解理论不了解实际应用

### 面试准备清单

- [ ] 理解各构建工具的核心原理和差异
- [ ] 掌握Webpack和Vite的配置和优化
- [ ] 了解插件开发机制和API
- [ ] 准备性能优化的实际案例
- [ ] 了解构建工具的选择标准
- [ ] 准备迁移和升级的经验分享

## 💡 总结

现代构建工具的核心要点：
1. **工具选择**：根据项目特点选择合适的构建工具
2. **性能优化**：掌握构建速度和包体积优化技巧
3. **配置管理**：理解配置原理，避免过度配置
4. **插件生态**：了解插件机制，必要时开发自定义插件
5. **持续优化**：关注构建工具的发展，适时升级

面试时要重点展示：
- 对构建工具原理的深入理解
- 实际的性能优化经验
- 工具选择和迁移的判断能力
- 解决复杂构建问题的能力 