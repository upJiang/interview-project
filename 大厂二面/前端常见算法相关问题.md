# å‰ç«¯å¸¸è§ç®—æ³•ç›¸å…³é—®é¢˜ - å‰ç«¯é¢è¯•æŒ‡å—

## ğŸ“‹ å¸¸è§é¢è¯•é¢˜ä¸ç­”æ¡ˆ

### Q1: å¦‚ä½•å®ç°æ•°ç»„å»é‡ï¼Ÿ

**æ ‡å‡†ç­”æ¡ˆï¼š**
ä½¿ç”¨Setã€Mapã€filterç­‰æ–¹æ³•å®ç°æ•°ç»„å»é‡ã€‚

**é¢è¯•å›ç­”æŠ€å·§ï¼š**
```javascript
// æ•°ç»„å»é‡å®ç°
class ArrayDeduplication {
  // æ–¹æ³•1ï¼šä½¿ç”¨Set
  deduplicateBySet(arr) {
    return [...new Set(arr)];
  }

  // æ–¹æ³•2ï¼šä½¿ç”¨Map
  deduplicateByMap(arr) {
    const map = new Map();
    return arr.filter(item => {
      if (map.has(item)) {
        return false;
      }
      map.set(item, true);
      return true;
    });
  }

  // æ–¹æ³•3ï¼šä½¿ç”¨filter + indexOf
  deduplicateByFilter(arr) {
    return arr.filter((item, index) => arr.indexOf(item) === index);
  }

  // æ–¹æ³•4ï¼šä½¿ç”¨reduce
  deduplicateByReduce(arr) {
    return arr.reduce((unique, item) => {
      return unique.includes(item) ? unique : [...unique, item];
    }, []);
  }

  // æ–¹æ³•5ï¼šå¯¹è±¡å»é‡ï¼ˆé€‚ç”¨äºå¯¹è±¡æ•°ç»„ï¼‰
  deduplicateObjects(arr, key) {
    const seen = new Set();
    return arr.filter(item => {
      const value = item[key];
      if (seen.has(value)) {
        return false;
      }
      seen.add(value);
      return true;
    });
  }
}
```

### Q2: å¦‚ä½•å®ç°æ•°ç»„æ’åºï¼Ÿ

**æ ‡å‡†ç­”æ¡ˆï¼š**
å®ç°å¿«é€Ÿæ’åºã€å½’å¹¶æ’åºã€å†’æ³¡æ’åºç­‰ç®—æ³•ã€‚

**é¢è¯•å›ç­”æŠ€å·§ï¼š**
```javascript
// æ’åºç®—æ³•å®ç°
class SortAlgorithms {
  // å¿«é€Ÿæ’åº
  quickSort(arr) {
    if (arr.length <= 1) return arr;
    
    const pivot = arr[Math.floor(arr.length / 2)];
    const left = arr.filter(item => item < pivot);
    const middle = arr.filter(item => item === pivot);
    const right = arr.filter(item => item > pivot);
    
    return [...this.quickSort(left), ...middle, ...this.quickSort(right)];
  }

  // å½’å¹¶æ’åº
  mergeSort(arr) {
    if (arr.length <= 1) return arr;
    
    const mid = Math.floor(arr.length / 2);
    const left = this.mergeSort(arr.slice(0, mid));
    const right = this.mergeSort(arr.slice(mid));
    
    return this.merge(left, right);
  }

  merge(left, right) {
    const result = [];
    let i = 0, j = 0;
    
    while (i < left.length && j < right.length) {
      if (left[i] <= right[j]) {
        result.push(left[i]);
        i++;
      } else {
        result.push(right[j]);
        j++;
      }
    }
    
    return result.concat(left.slice(i), right.slice(j));
  }

  // å†’æ³¡æ’åº
  bubbleSort(arr) {
    const result = [...arr];
    const len = result.length;
    
    for (let i = 0; i < len - 1; i++) {
      for (let j = 0; j < len - 1 - i; j++) {
        if (result[j] > result[j + 1]) {
          [result[j], result[j + 1]] = [result[j + 1], result[j]];
        }
      }
    }
    
    return result;
  }

  // é€‰æ‹©æ’åº
  selectionSort(arr) {
    const result = [...arr];
    const len = result.length;
    
    for (let i = 0; i < len - 1; i++) {
      let minIndex = i;
      for (let j = i + 1; j < len; j++) {
        if (result[j] < result[minIndex]) {
          minIndex = j;
        }
      }
      if (minIndex !== i) {
        [result[i], result[minIndex]] = [result[minIndex], result[i]];
      }
    }
    
    return result;
  }
}
```

### Q3: å¦‚ä½•å®ç°äºŒåˆ†æŸ¥æ‰¾ï¼Ÿ

**æ ‡å‡†ç­”æ¡ˆï¼š**
åœ¨æœ‰åºæ•°ç»„ä¸­æŸ¥æ‰¾ç›®æ ‡å€¼ï¼Œæ—¶é—´å¤æ‚åº¦O(log n)ã€‚

**é¢è¯•å›ç­”æŠ€å·§ï¼š**
```javascript
// äºŒåˆ†æŸ¥æ‰¾å®ç°
class BinarySearch {
  // æ ‡å‡†äºŒåˆ†æŸ¥æ‰¾
  search(arr, target) {
    let left = 0;
    let right = arr.length - 1;
    
    while (left <= right) {
      const mid = Math.floor((left + right) / 2);
      
      if (arr[mid] === target) {
        return mid;
      } else if (arr[mid] < target) {
        left = mid + 1;
      } else {
        right = mid - 1;
      }
    }
    
    return -1; // æœªæ‰¾åˆ°
  }

  // æŸ¥æ‰¾ç¬¬ä¸€ä¸ªç­‰äºç›®æ ‡å€¼çš„ä½ç½®
  searchFirst(arr, target) {
    let left = 0;
    let right = arr.length - 1;
    let result = -1;
    
    while (left <= right) {
      const mid = Math.floor((left + right) / 2);
      
      if (arr[mid] === target) {
        result = mid;
        right = mid - 1; // ç»§ç»­å‘å·¦æŸ¥æ‰¾
      } else if (arr[mid] < target) {
        left = mid + 1;
      } else {
        right = mid - 1;
      }
    }
    
    return result;
  }

  // æŸ¥æ‰¾æœ€åä¸€ä¸ªç­‰äºç›®æ ‡å€¼çš„ä½ç½®
  searchLast(arr, target) {
    let left = 0;
    let right = arr.length - 1;
    let result = -1;
    
    while (left <= right) {
      const mid = Math.floor((left + right) / 2);
      
      if (arr[mid] === target) {
        result = mid;
        left = mid + 1; // ç»§ç»­å‘å³æŸ¥æ‰¾
      } else if (arr[mid] < target) {
        left = mid + 1;
      } else {
        right = mid - 1;
      }
    }
    
    return result;
  }

  // æŸ¥æ‰¾æ’å…¥ä½ç½®
  searchInsert(arr, target) {
    let left = 0;
    let right = arr.length - 1;
    
    while (left <= right) {
      const mid = Math.floor((left + right) / 2);
      
      if (arr[mid] === target) {
        return mid;
      } else if (arr[mid] < target) {
        left = mid + 1;
      } else {
        right = mid - 1;
      }
    }
    
    return left; // è¿”å›æ’å…¥ä½ç½®
  }
}
```

### Q4: å¦‚ä½•å®ç°æ·±åº¦ä¼˜å…ˆæœç´¢(DFS)å’Œå¹¿åº¦ä¼˜å…ˆæœç´¢(BFS)ï¼Ÿ

**æ ‡å‡†ç­”æ¡ˆï¼š**
DFSä½¿ç”¨é€’å½’æˆ–æ ˆï¼ŒBFSä½¿ç”¨é˜Ÿåˆ—ã€‚

**é¢è¯•å›ç­”æŠ€å·§ï¼š**
```javascript
// å›¾æœç´¢ç®—æ³•
class GraphSearch {
  constructor() {
    this.graph = new Map();
  }

  // æ·»åŠ è¾¹
  addEdge(from, to) {
    if (!this.graph.has(from)) {
      this.graph.set(from, []);
    }
    this.graph.get(from).push(to);
  }

  // æ·±åº¦ä¼˜å…ˆæœç´¢
  dfs(start, visited = new Set()) {
    visited.add(start);
    console.log('Visiting:', start);
    
    const neighbors = this.graph.get(start) || [];
    for (const neighbor of neighbors) {
      if (!visited.has(neighbor)) {
        this.dfs(neighbor, visited);
      }
    }
  }

  // æ·±åº¦ä¼˜å…ˆæœç´¢ï¼ˆè¿­ä»£ç‰ˆæœ¬ï¼‰
  dfsIterative(start) {
    const stack = [start];
    const visited = new Set();
    
    while (stack.length > 0) {
      const current = stack.pop();
      
      if (!visited.has(current)) {
        visited.add(current);
        console.log('Visiting:', current);
        
        const neighbors = this.graph.get(current) || [];
        for (let i = neighbors.length - 1; i >= 0; i--) {
          if (!visited.has(neighbors[i])) {
            stack.push(neighbors[i]);
          }
        }
      }
    }
  }

  // å¹¿åº¦ä¼˜å…ˆæœç´¢
  bfs(start) {
    const queue = [start];
    const visited = new Set([start]);
    
    while (queue.length > 0) {
      const current = queue.shift();
      console.log('Visiting:', current);
      
      const neighbors = this.graph.get(current) || [];
      for (const neighbor of neighbors) {
        if (!visited.has(neighbor)) {
          visited.add(neighbor);
          queue.push(neighbor);
        }
      }
    }
  }

  // æŸ¥æ‰¾æœ€çŸ­è·¯å¾„
  findShortestPath(start, end) {
    const queue = [[start, [start]]];
    const visited = new Set([start]);
    
    while (queue.length > 0) {
      const [current, path] = queue.shift();
      
      if (current === end) {
        return path;
      }
      
      const neighbors = this.graph.get(current) || [];
      for (const neighbor of neighbors) {
        if (!visited.has(neighbor)) {
          visited.add(neighbor);
          queue.push([neighbor, [...path, neighbor]]);
        }
      }
    }
    
    return null; // æœªæ‰¾åˆ°è·¯å¾„
  }
}
```

### Q5: å¦‚ä½•å®ç°åŠ¨æ€è§„åˆ’ï¼Ÿ

**æ ‡å‡†ç­”æ¡ˆï¼š**
ä½¿ç”¨è®°å¿†åŒ–æˆ–è‡ªåº•å‘ä¸Šçš„æ–¹æ³•è§£å†³é‡å å­é—®é¢˜ã€‚

**é¢è¯•å›ç­”æŠ€å·§ï¼š**
```javascript
// åŠ¨æ€è§„åˆ’ç®—æ³•
class DynamicProgramming {
  // æ–æ³¢é‚£å¥‘æ•°åˆ—
  fibonacci(n, memo = new Map()) {
    if (n <= 1) return n;
    if (memo.has(n)) return memo.get(n);
    
    const result = this.fibonacci(n - 1, memo) + this.fibonacci(n - 2, memo);
    memo.set(n, result);
    return result;
  }

  // æ–æ³¢é‚£å¥‘æ•°åˆ—ï¼ˆè‡ªåº•å‘ä¸Šï¼‰
  fibonacciBottomUp(n) {
    if (n <= 1) return n;
    
    const dp = new Array(n + 1);
    dp[0] = 0;
    dp[1] = 1;
    
    for (let i = 2; i <= n; i++) {
      dp[i] = dp[i - 1] + dp[i - 2];
    }
    
    return dp[n];
  }

  // æœ€é•¿é€’å¢å­åºåˆ—
  longestIncreasingSubsequence(nums) {
    if (nums.length === 0) return 0;
    
    const dp = new Array(nums.length).fill(1);
    let maxLength = 1;
    
    for (let i = 1; i < nums.length; i++) {
      for (let j = 0; j < i; j++) {
        if (nums[i] > nums[j]) {
          dp[i] = Math.max(dp[i], dp[j] + 1);
        }
      }
      maxLength = Math.max(maxLength, dp[i]);
    }
    
    return maxLength;
  }

  // èƒŒåŒ…é—®é¢˜
  knapsack(weights, values, capacity) {
    const n = weights.length;
    const dp = Array(n + 1).fill().map(() => Array(capacity + 1).fill(0));
    
    for (let i = 1; i <= n; i++) {
      for (let w = 0; w <= capacity; w++) {
        if (weights[i - 1] <= w) {
          dp[i][w] = Math.max(
            dp[i - 1][w],
            dp[i - 1][w - weights[i - 1]] + values[i - 1]
          );
        } else {
          dp[i][w] = dp[i - 1][w];
        }
      }
    }
    
    return dp[n][capacity];
  }

  // ç¼–è¾‘è·ç¦»
  editDistance(word1, word2) {
    const m = word1.length;
    const n = word2.length;
    const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));
    
    // åˆå§‹åŒ–ç¬¬ä¸€è¡Œå’Œç¬¬ä¸€åˆ—
    for (let i = 0; i <= m; i++) dp[i][0] = i;
    for (let j = 0; j <= n; j++) dp[0][j] = j;
    
    for (let i = 1; i <= m; i++) {
      for (let j = 1; j <= n; j++) {
        if (word1[i - 1] === word2[j - 1]) {
          dp[i][j] = dp[i - 1][j - 1];
        } else {
          dp[i][j] = Math.min(
            dp[i - 1][j] + 1,     // åˆ é™¤
            dp[i][j - 1] + 1,     // æ’å…¥
            dp[i - 1][j - 1] + 1  // æ›¿æ¢
          );
        }
      }
    }
    
    return dp[m][n];
  }
}
```

### Q6: å¦‚ä½•å®ç°LRUç¼“å­˜ï¼Ÿ

**æ ‡å‡†ç­”æ¡ˆï¼š**
ä½¿ç”¨Mapæˆ–åŒå‘é“¾è¡¨å®ç°æœ€è¿‘æœ€å°‘ä½¿ç”¨ç¼“å­˜ã€‚

**é¢è¯•å›ç­”æŠ€å·§ï¼š**
```javascript
// LRUç¼“å­˜å®ç°
class LRUCache {
  constructor(capacity) {
    this.capacity = capacity;
    this.cache = new Map();
  }

  get(key) {
    if (this.cache.has(key)) {
      // ç§»åŠ¨åˆ°æœ«å°¾ï¼ˆæœ€è¿‘ä½¿ç”¨ï¼‰
      const value = this.cache.get(key);
      this.cache.delete(key);
      this.cache.set(key, value);
      return value;
    }
    return -1;
  }

  put(key, value) {
    if (this.cache.has(key)) {
      // æ›´æ–°ç°æœ‰å€¼
      this.cache.delete(key);
    } else if (this.cache.size >= this.capacity) {
      // åˆ é™¤æœ€ä¹…æœªä½¿ç”¨çš„é¡¹ï¼ˆç¬¬ä¸€ä¸ªï¼‰
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
    
    this.cache.set(key, value);
  }
}

// åŒå‘é“¾è¡¨å®ç°çš„LRUç¼“å­˜
class LRUCacheWithLinkedList {
  constructor(capacity) {
    this.capacity = capacity;
    this.cache = new Map();
    this.head = new Node(0, 0);
    this.tail = new Node(0, 0);
    this.head.next = this.tail;
    this.tail.prev = this.head;
  }

  get(key) {
    if (this.cache.has(key)) {
      const node = this.cache.get(key);
      this.moveToTail(node);
      return node.value;
    }
    return -1;
  }

  put(key, value) {
    if (this.cache.has(key)) {
      const node = this.cache.get(key);
      node.value = value;
      this.moveToTail(node);
    } else {
      const newNode = new Node(key, value);
      this.cache.set(key, newNode);
      this.addToTail(newNode);
      
      if (this.cache.size > this.capacity) {
        const lru = this.head.next;
        this.removeNode(lru);
        this.cache.delete(lru.key);
      }
    }
  }

  moveToTail(node) {
    this.removeNode(node);
    this.addToTail(node);
  }

  removeNode(node) {
    node.prev.next = node.next;
    node.next.prev = node.prev;
  }

  addToTail(node) {
    node.prev = this.tail.prev;
    node.next = this.tail;
    this.tail.prev.next = node;
    this.tail.prev = node;
  }
}

class Node {
  constructor(key, value) {
    this.key = key;
    this.value = value;
    this.prev = null;
    this.next = null;
  }
}
```

### Q7: å¦‚ä½•å®ç°å­—ç¬¦ä¸²åŒ¹é…ç®—æ³•ï¼Ÿ

**æ ‡å‡†ç­”æ¡ˆï¼š**
å®ç°KMPã€Boyer-Mooreç­‰å­—ç¬¦ä¸²åŒ¹é…ç®—æ³•ã€‚

**é¢è¯•å›ç­”æŠ€å·§ï¼š**
```javascript
// å­—ç¬¦ä¸²åŒ¹é…ç®—æ³•
class StringMatching {
  // æœ´ç´ å­—ç¬¦ä¸²åŒ¹é…
  naiveSearch(text, pattern) {
    const n = text.length;
    const m = pattern.length;
    const result = [];
    
    for (let i = 0; i <= n - m; i++) {
      let j = 0;
      while (j < m && text[i + j] === pattern[j]) {
        j++;
      }
      if (j === m) {
        result.push(i);
      }
    }
    
    return result;
  }

  // KMPç®—æ³•
  kmpSearch(text, pattern) {
    const lps = this.computeLPS(pattern);
    const n = text.length;
    const m = pattern.length;
    const result = [];
    
    let i = 0, j = 0;
    while (i < n) {
      if (pattern[j] === text[i]) {
        i++;
        j++;
      }
      
      if (j === m) {
        result.push(i - j);
        j = lps[j - 1];
      } else if (i < n && pattern[j] !== text[i]) {
        if (j !== 0) {
          j = lps[j - 1];
        } else {
          i++;
        }
      }
    }
    
    return result;
  }

  // è®¡ç®—æœ€é•¿å…¬å…±å‰åç¼€
  computeLPS(pattern) {
    const lps = new Array(pattern.length).fill(0);
    let len = 0;
    let i = 1;
    
    while (i < pattern.length) {
      if (pattern[i] === pattern[len]) {
        len++;
        lps[i] = len;
        i++;
      } else {
        if (len !== 0) {
          len = lps[len - 1];
        } else {
          lps[i] = 0;
          i++;
        }
      }
    }
    
    return lps;
  }

  // Boyer-Mooreç®—æ³•
  boyerMooreSearch(text, pattern) {
    const badCharTable = this.buildBadCharTable(pattern);
    const goodSuffixTable = this.buildGoodSuffixTable(pattern);
    const result = [];
    
    let i = pattern.length - 1;
    while (i < text.length) {
      let j = pattern.length - 1;
      let k = i;
      
      while (j >= 0 && text[k] === pattern[j]) {
        k--;
        j--;
      }
      
      if (j === -1) {
        result.push(k + 1);
        i += pattern.length;
      } else {
        const badCharShift = badCharTable.get(text[k]) || pattern.length;
        const goodSuffixShift = goodSuffixTable[j];
        i += Math.max(badCharShift, goodSuffixShift);
      }
    }
    
    return result;
  }

  buildBadCharTable(pattern) {
    const table = new Map();
    for (let i = 0; i < pattern.length - 1; i++) {
      table.set(pattern[i], pattern.length - 1 - i);
    }
    return table;
  }

  buildGoodSuffixTable(pattern) {
    const table = new Array(pattern.length).fill(pattern.length);
    let lastPrefix = pattern.length;
    
    for (let i = pattern.length - 1; i >= 0; i--) {
      if (this.isPrefix(pattern, i + 1)) {
        lastPrefix = i + 1;
      }
      table[i] = lastPrefix + pattern.length - 1 - i;
    }
    
    for (let i = 0; i < pattern.length - 1; i++) {
      const suffixLength = pattern.length - 1 - i;
      const suffix = pattern.substring(i + 1);
      const prefix = pattern.substring(0, suffixLength);
      
      if (suffix === prefix) {
        table[i] = pattern.length - 1 - i + lastPrefix;
      }
    }
    
    return table;
  }

  isPrefix(pattern, p) {
    for (let i = p, j = 0; i < pattern.length; i++, j++) {
      if (pattern[i] !== pattern[j]) {
        return false;
      }
    }
    return true;
  }
}
```

## ğŸ¯ é¢è¯•æŠ€å·§æ€»ç»“

### å›ç­”ç­–ç•¥

**1. ç®—æ³•ç†è§£**
- ç†è§£ç®—æ³•çš„æ ¸å¿ƒæ€æƒ³å’Œæ—¶é—´å¤æ‚åº¦
- èƒ½å¤Ÿåˆ†æç®—æ³•çš„ä¼˜ç¼ºç‚¹

**2. ä»£ç å®ç°**
- å±•ç¤ºæ¸…æ™°çš„ä»£ç å®ç°
- è¯´æ˜å…³é”®æ­¥éª¤å’Œè¾¹ç•Œæ¡ä»¶

**3. ä¼˜åŒ–æ€ç»´**
- è€ƒè™‘æ—¶é—´å¤æ‚åº¦å’Œç©ºé—´å¤æ‚åº¦
- æå‡ºä¼˜åŒ–æ–¹æ¡ˆ

### åŠ åˆ†ç‚¹

1. **ç®—æ³•æ€ç»´**ï¼šå±•ç¤ºå¯¹ç®—æ³•çš„æ·±å…¥ç†è§£
2. **ä»£ç è´¨é‡**ï¼šå†™å‡ºæ¸…æ™°ã€é«˜æ•ˆçš„ä»£ç 
3. **ä¼˜åŒ–æ„è¯†**ï¼šä¸»åŠ¨è€ƒè™‘æ€§èƒ½ä¼˜åŒ–
4. **å®é™…åº”ç”¨**ï¼šç»“åˆå‰ç«¯å®é™…åœºæ™¯

### å¸¸è§è¯¯åŒº

1. **åªèƒŒç®—æ³•**ï¼šè¦ç†è§£ç®—æ³•åŸç†
2. **å¿½è§†å¤æ‚åº¦**ï¼šè¦æ³¨æ„æ—¶é—´å’Œç©ºé—´å¤æ‚åº¦
3. **ç¼ºä¹å®è·µ**ï¼šè¦æœ‰å®é™…çš„ç¼–ç ç»éªŒ
4. **ä¸ç»“åˆåœºæ™¯**ï¼šè¦ç»“åˆå‰ç«¯å®é™…åº”ç”¨

### é¢è¯•å‡†å¤‡æ¸…å•

- [ ] æŒæ¡åŸºç¡€æ’åºå’Œæœç´¢ç®—æ³•
- [ ] ç†è§£åŠ¨æ€è§„åˆ’æ€æƒ³
- [ ] æŒæ¡å­—ç¬¦ä¸²åŒ¹é…ç®—æ³•
- [ ] äº†è§£æ•°æ®ç»“æ„ï¼ˆæ ˆã€é˜Ÿåˆ—ã€é“¾è¡¨ã€æ ‘ï¼‰
- [ ] å‡†å¤‡å®é™…åº”ç”¨æ¡ˆä¾‹
- [ ] ç»ƒä¹ æ‰‹å†™ä»£ç 

## ğŸ’¡ æ€»ç»“

å‰ç«¯å¸¸è§ç®—æ³•ä¸»è¦ç”¨äºï¼š
1. **æ•°æ®å¤„ç†**ï¼šæ•°ç»„æ“ä½œã€å­—ç¬¦ä¸²å¤„ç†
2. **æ€§èƒ½ä¼˜åŒ–**ï¼šç¼“å­˜ç­–ç•¥ã€æœç´¢ä¼˜åŒ–
3. **é—®é¢˜è§£å†³**ï¼šåŠ¨æ€è§„åˆ’ã€å›¾ç®—æ³•
4. **ä»£ç è´¨é‡**ï¼šç®—æ³•æ€ç»´ã€ä¼˜åŒ–æ„è¯†

é¢è¯•æ—¶è¦é‡ç‚¹å±•ç¤ºï¼š
- å¯¹ç®—æ³•åŸç†çš„ç†è§£
- æ¸…æ™°çš„ä»£ç å®ç°èƒ½åŠ›
- æ€§èƒ½ä¼˜åŒ–å’Œå¤æ‚åº¦åˆ†æ
- å®é™…åº”ç”¨å’Œé—®é¢˜è§£å†³èƒ½åŠ› 