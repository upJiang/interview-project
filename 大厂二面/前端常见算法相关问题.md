# 前端常见算法相关问题 - 前端面试指南

## 📋 常见面试题与答案

### Q1: 如何实现数组去重？

**标准答案：**
使用Set、Map、filter等方法实现数组去重。

**面试回答技巧：**
```javascript
// 数组去重实现
class ArrayDeduplication {
  // 方法1：使用Set
  deduplicateBySet(arr) {
    return [...new Set(arr)];
  }

  // 方法2：使用Map
  deduplicateByMap(arr) {
    const map = new Map();
    return arr.filter(item => {
      if (map.has(item)) {
        return false;
      }
      map.set(item, true);
      return true;
    });
  }

  // 方法3：使用filter + indexOf
  deduplicateByFilter(arr) {
    return arr.filter((item, index) => arr.indexOf(item) === index);
  }

  // 方法4：使用reduce
  deduplicateByReduce(arr) {
    return arr.reduce((unique, item) => {
      return unique.includes(item) ? unique : [...unique, item];
    }, []);
  }

  // 方法5：对象去重（适用于对象数组）
  deduplicateObjects(arr, key) {
    const seen = new Set();
    return arr.filter(item => {
      const value = item[key];
      if (seen.has(value)) {
        return false;
      }
      seen.add(value);
      return true;
    });
  }
}
```

### Q2: 如何实现数组排序？

**标准答案：**
实现快速排序、归并排序、冒泡排序等算法。

**面试回答技巧：**
```javascript
// 排序算法实现
class SortAlgorithms {
  // 快速排序
  quickSort(arr) {
    if (arr.length <= 1) return arr;
    
    const pivot = arr[Math.floor(arr.length / 2)];
    const left = arr.filter(item => item < pivot);
    const middle = arr.filter(item => item === pivot);
    const right = arr.filter(item => item > pivot);
    
    return [...this.quickSort(left), ...middle, ...this.quickSort(right)];
  }

  // 归并排序
  mergeSort(arr) {
    if (arr.length <= 1) return arr;
    
    const mid = Math.floor(arr.length / 2);
    const left = this.mergeSort(arr.slice(0, mid));
    const right = this.mergeSort(arr.slice(mid));
    
    return this.merge(left, right);
  }

  merge(left, right) {
    const result = [];
    let i = 0, j = 0;
    
    while (i < left.length && j < right.length) {
      if (left[i] <= right[j]) {
        result.push(left[i]);
        i++;
      } else {
        result.push(right[j]);
        j++;
      }
    }
    
    return result.concat(left.slice(i), right.slice(j));
  }

  // 冒泡排序
  bubbleSort(arr) {
    const result = [...arr];
    const len = result.length;
    
    for (let i = 0; i < len - 1; i++) {
      for (let j = 0; j < len - 1 - i; j++) {
        if (result[j] > result[j + 1]) {
          [result[j], result[j + 1]] = [result[j + 1], result[j]];
        }
      }
    }
    
    return result;
  }

  // 选择排序
  selectionSort(arr) {
    const result = [...arr];
    const len = result.length;
    
    for (let i = 0; i < len - 1; i++) {
      let minIndex = i;
      for (let j = i + 1; j < len; j++) {
        if (result[j] < result[minIndex]) {
          minIndex = j;
        }
      }
      if (minIndex !== i) {
        [result[i], result[minIndex]] = [result[minIndex], result[i]];
      }
    }
    
    return result;
  }
}
```

### Q3: 如何实现二分查找？

**标准答案：**
在有序数组中查找目标值，时间复杂度O(log n)。

**面试回答技巧：**
```javascript
// 二分查找实现
class BinarySearch {
  // 标准二分查找
  search(arr, target) {
    let left = 0;
    let right = arr.length - 1;
    
    while (left <= right) {
      const mid = Math.floor((left + right) / 2);
      
      if (arr[mid] === target) {
        return mid;
      } else if (arr[mid] < target) {
        left = mid + 1;
      } else {
        right = mid - 1;
      }
    }
    
    return -1; // 未找到
  }

  // 查找第一个等于目标值的位置
  searchFirst(arr, target) {
    let left = 0;
    let right = arr.length - 1;
    let result = -1;
    
    while (left <= right) {
      const mid = Math.floor((left + right) / 2);
      
      if (arr[mid] === target) {
        result = mid;
        right = mid - 1; // 继续向左查找
      } else if (arr[mid] < target) {
        left = mid + 1;
      } else {
        right = mid - 1;
      }
    }
    
    return result;
  }

  // 查找最后一个等于目标值的位置
  searchLast(arr, target) {
    let left = 0;
    let right = arr.length - 1;
    let result = -1;
    
    while (left <= right) {
      const mid = Math.floor((left + right) / 2);
      
      if (arr[mid] === target) {
        result = mid;
        left = mid + 1; // 继续向右查找
      } else if (arr[mid] < target) {
        left = mid + 1;
      } else {
        right = mid - 1;
      }
    }
    
    return result;
  }

  // 查找插入位置
  searchInsert(arr, target) {
    let left = 0;
    let right = arr.length - 1;
    
    while (left <= right) {
      const mid = Math.floor((left + right) / 2);
      
      if (arr[mid] === target) {
        return mid;
      } else if (arr[mid] < target) {
        left = mid + 1;
      } else {
        right = mid - 1;
      }
    }
    
    return left; // 返回插入位置
  }
}
```

### Q4: 如何实现深度优先搜索(DFS)和广度优先搜索(BFS)？

**标准答案：**
DFS使用递归或栈，BFS使用队列。

**面试回答技巧：**
```javascript
// 图搜索算法
class GraphSearch {
  constructor() {
    this.graph = new Map();
  }

  // 添加边
  addEdge(from, to) {
    if (!this.graph.has(from)) {
      this.graph.set(from, []);
    }
    this.graph.get(from).push(to);
  }

  // 深度优先搜索
  dfs(start, visited = new Set()) {
    visited.add(start);
    console.log('Visiting:', start);
    
    const neighbors = this.graph.get(start) || [];
    for (const neighbor of neighbors) {
      if (!visited.has(neighbor)) {
        this.dfs(neighbor, visited);
      }
    }
  }

  // 深度优先搜索（迭代版本）
  dfsIterative(start) {
    const stack = [start];
    const visited = new Set();
    
    while (stack.length > 0) {
      const current = stack.pop();
      
      if (!visited.has(current)) {
        visited.add(current);
        console.log('Visiting:', current);
        
        const neighbors = this.graph.get(current) || [];
        for (let i = neighbors.length - 1; i >= 0; i--) {
          if (!visited.has(neighbors[i])) {
            stack.push(neighbors[i]);
          }
        }
      }
    }
  }

  // 广度优先搜索
  bfs(start) {
    const queue = [start];
    const visited = new Set([start]);
    
    while (queue.length > 0) {
      const current = queue.shift();
      console.log('Visiting:', current);
      
      const neighbors = this.graph.get(current) || [];
      for (const neighbor of neighbors) {
        if (!visited.has(neighbor)) {
          visited.add(neighbor);
          queue.push(neighbor);
        }
      }
    }
  }

  // 查找最短路径
  findShortestPath(start, end) {
    const queue = [[start, [start]]];
    const visited = new Set([start]);
    
    while (queue.length > 0) {
      const [current, path] = queue.shift();
      
      if (current === end) {
        return path;
      }
      
      const neighbors = this.graph.get(current) || [];
      for (const neighbor of neighbors) {
        if (!visited.has(neighbor)) {
          visited.add(neighbor);
          queue.push([neighbor, [...path, neighbor]]);
        }
      }
    }
    
    return null; // 未找到路径
  }
}
```

### Q5: 如何实现动态规划？

**标准答案：**
使用记忆化或自底向上的方法解决重叠子问题。

**面试回答技巧：**
```javascript
// 动态规划算法
class DynamicProgramming {
  // 斐波那契数列
  fibonacci(n, memo = new Map()) {
    if (n <= 1) return n;
    if (memo.has(n)) return memo.get(n);
    
    const result = this.fibonacci(n - 1, memo) + this.fibonacci(n - 2, memo);
    memo.set(n, result);
    return result;
  }

  // 斐波那契数列（自底向上）
  fibonacciBottomUp(n) {
    if (n <= 1) return n;
    
    const dp = new Array(n + 1);
    dp[0] = 0;
    dp[1] = 1;
    
    for (let i = 2; i <= n; i++) {
      dp[i] = dp[i - 1] + dp[i - 2];
    }
    
    return dp[n];
  }

  // 最长递增子序列
  longestIncreasingSubsequence(nums) {
    if (nums.length === 0) return 0;
    
    const dp = new Array(nums.length).fill(1);
    let maxLength = 1;
    
    for (let i = 1; i < nums.length; i++) {
      for (let j = 0; j < i; j++) {
        if (nums[i] > nums[j]) {
          dp[i] = Math.max(dp[i], dp[j] + 1);
        }
      }
      maxLength = Math.max(maxLength, dp[i]);
    }
    
    return maxLength;
  }

  // 背包问题
  knapsack(weights, values, capacity) {
    const n = weights.length;
    const dp = Array(n + 1).fill().map(() => Array(capacity + 1).fill(0));
    
    for (let i = 1; i <= n; i++) {
      for (let w = 0; w <= capacity; w++) {
        if (weights[i - 1] <= w) {
          dp[i][w] = Math.max(
            dp[i - 1][w],
            dp[i - 1][w - weights[i - 1]] + values[i - 1]
          );
        } else {
          dp[i][w] = dp[i - 1][w];
        }
      }
    }
    
    return dp[n][capacity];
  }

  // 编辑距离
  editDistance(word1, word2) {
    const m = word1.length;
    const n = word2.length;
    const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));
    
    // 初始化第一行和第一列
    for (let i = 0; i <= m; i++) dp[i][0] = i;
    for (let j = 0; j <= n; j++) dp[0][j] = j;
    
    for (let i = 1; i <= m; i++) {
      for (let j = 1; j <= n; j++) {
        if (word1[i - 1] === word2[j - 1]) {
          dp[i][j] = dp[i - 1][j - 1];
        } else {
          dp[i][j] = Math.min(
            dp[i - 1][j] + 1,     // 删除
            dp[i][j - 1] + 1,     // 插入
            dp[i - 1][j - 1] + 1  // 替换
          );
        }
      }
    }
    
    return dp[m][n];
  }
}
```

### Q6: 如何实现LRU缓存？

**标准答案：**
使用Map或双向链表实现最近最少使用缓存。

**面试回答技巧：**
```javascript
// LRU缓存实现
class LRUCache {
  constructor(capacity) {
    this.capacity = capacity;
    this.cache = new Map();
  }

  get(key) {
    if (this.cache.has(key)) {
      // 移动到末尾（最近使用）
      const value = this.cache.get(key);
      this.cache.delete(key);
      this.cache.set(key, value);
      return value;
    }
    return -1;
  }

  put(key, value) {
    if (this.cache.has(key)) {
      // 更新现有值
      this.cache.delete(key);
    } else if (this.cache.size >= this.capacity) {
      // 删除最久未使用的项（第一个）
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
    
    this.cache.set(key, value);
  }
}

// 双向链表实现的LRU缓存
class LRUCacheWithLinkedList {
  constructor(capacity) {
    this.capacity = capacity;
    this.cache = new Map();
    this.head = new Node(0, 0);
    this.tail = new Node(0, 0);
    this.head.next = this.tail;
    this.tail.prev = this.head;
  }

  get(key) {
    if (this.cache.has(key)) {
      const node = this.cache.get(key);
      this.moveToTail(node);
      return node.value;
    }
    return -1;
  }

  put(key, value) {
    if (this.cache.has(key)) {
      const node = this.cache.get(key);
      node.value = value;
      this.moveToTail(node);
    } else {
      const newNode = new Node(key, value);
      this.cache.set(key, newNode);
      this.addToTail(newNode);
      
      if (this.cache.size > this.capacity) {
        const lru = this.head.next;
        this.removeNode(lru);
        this.cache.delete(lru.key);
      }
    }
  }

  moveToTail(node) {
    this.removeNode(node);
    this.addToTail(node);
  }

  removeNode(node) {
    node.prev.next = node.next;
    node.next.prev = node.prev;
  }

  addToTail(node) {
    node.prev = this.tail.prev;
    node.next = this.tail;
    this.tail.prev.next = node;
    this.tail.prev = node;
  }
}

class Node {
  constructor(key, value) {
    this.key = key;
    this.value = value;
    this.prev = null;
    this.next = null;
  }
}
```

### Q7: 如何实现字符串匹配算法？

**标准答案：**
实现KMP、Boyer-Moore等字符串匹配算法。

**面试回答技巧：**
```javascript
// 字符串匹配算法
class StringMatching {
  // 朴素字符串匹配
  naiveSearch(text, pattern) {
    const n = text.length;
    const m = pattern.length;
    const result = [];
    
    for (let i = 0; i <= n - m; i++) {
      let j = 0;
      while (j < m && text[i + j] === pattern[j]) {
        j++;
      }
      if (j === m) {
        result.push(i);
      }
    }
    
    return result;
  }

  // KMP算法
  kmpSearch(text, pattern) {
    const lps = this.computeLPS(pattern);
    const n = text.length;
    const m = pattern.length;
    const result = [];
    
    let i = 0, j = 0;
    while (i < n) {
      if (pattern[j] === text[i]) {
        i++;
        j++;
      }
      
      if (j === m) {
        result.push(i - j);
        j = lps[j - 1];
      } else if (i < n && pattern[j] !== text[i]) {
        if (j !== 0) {
          j = lps[j - 1];
        } else {
          i++;
        }
      }
    }
    
    return result;
  }

  // 计算最长公共前后缀
  computeLPS(pattern) {
    const lps = new Array(pattern.length).fill(0);
    let len = 0;
    let i = 1;
    
    while (i < pattern.length) {
      if (pattern[i] === pattern[len]) {
        len++;
        lps[i] = len;
        i++;
      } else {
        if (len !== 0) {
          len = lps[len - 1];
        } else {
          lps[i] = 0;
          i++;
        }
      }
    }
    
    return lps;
  }

  // Boyer-Moore算法
  boyerMooreSearch(text, pattern) {
    const badCharTable = this.buildBadCharTable(pattern);
    const goodSuffixTable = this.buildGoodSuffixTable(pattern);
    const result = [];
    
    let i = pattern.length - 1;
    while (i < text.length) {
      let j = pattern.length - 1;
      let k = i;
      
      while (j >= 0 && text[k] === pattern[j]) {
        k--;
        j--;
      }
      
      if (j === -1) {
        result.push(k + 1);
        i += pattern.length;
      } else {
        const badCharShift = badCharTable.get(text[k]) || pattern.length;
        const goodSuffixShift = goodSuffixTable[j];
        i += Math.max(badCharShift, goodSuffixShift);
      }
    }
    
    return result;
  }

  buildBadCharTable(pattern) {
    const table = new Map();
    for (let i = 0; i < pattern.length - 1; i++) {
      table.set(pattern[i], pattern.length - 1 - i);
    }
    return table;
  }

  buildGoodSuffixTable(pattern) {
    const table = new Array(pattern.length).fill(pattern.length);
    let lastPrefix = pattern.length;
    
    for (let i = pattern.length - 1; i >= 0; i--) {
      if (this.isPrefix(pattern, i + 1)) {
        lastPrefix = i + 1;
      }
      table[i] = lastPrefix + pattern.length - 1 - i;
    }
    
    for (let i = 0; i < pattern.length - 1; i++) {
      const suffixLength = pattern.length - 1 - i;
      const suffix = pattern.substring(i + 1);
      const prefix = pattern.substring(0, suffixLength);
      
      if (suffix === prefix) {
        table[i] = pattern.length - 1 - i + lastPrefix;
      }
    }
    
    return table;
  }

  isPrefix(pattern, p) {
    for (let i = p, j = 0; i < pattern.length; i++, j++) {
      if (pattern[i] !== pattern[j]) {
        return false;
      }
    }
    return true;
  }
}
```

## 🎯 面试技巧总结

### 回答策略

**1. 算法理解**
- 理解算法的核心思想和时间复杂度
- 能够分析算法的优缺点

**2. 代码实现**
- 展示清晰的代码实现
- 说明关键步骤和边界条件

**3. 优化思维**
- 考虑时间复杂度和空间复杂度
- 提出优化方案

### 加分点

1. **算法思维**：展示对算法的深入理解
2. **代码质量**：写出清晰、高效的代码
3. **优化意识**：主动考虑性能优化
4. **实际应用**：结合前端实际场景

### 常见误区

1. **只背算法**：要理解算法原理
2. **忽视复杂度**：要注意时间和空间复杂度
3. **缺乏实践**：要有实际的编码经验
4. **不结合场景**：要结合前端实际应用

### 面试准备清单

- [ ] 掌握基础排序和搜索算法
- [ ] 理解动态规划思想
- [ ] 掌握字符串匹配算法
- [ ] 了解数据结构（栈、队列、链表、树）
- [ ] 准备实际应用案例
- [ ] 练习手写代码

## 💡 总结

前端常见算法主要用于：
1. **数据处理**：数组操作、字符串处理
2. **性能优化**：缓存策略、搜索优化
3. **问题解决**：动态规划、图算法
4. **代码质量**：算法思维、优化意识

面试时要重点展示：
- 对算法原理的理解
- 清晰的代码实现能力
- 性能优化和复杂度分析
- 实际应用和问题解决能力 