# 常见设计模式相关问题 - 前端面试指南

## 📋 常见面试题与答案

### Q1: 什么是设计模式？前端开发中常用的设计模式有哪些？

**标准答案：**
设计模式是解决软件设计中常见问题的可重用解决方案。前端常用模式包括单例、工厂、观察者、策略等。

**面试回答技巧：**
```javascript
// 设计模式分类
class DesignPatterns {
  // 创建型模式：单例、工厂、建造者
  // 结构型模式：适配器、装饰器、代理
  // 行为型模式：观察者、策略、命令
  
  constructor() {
    this.patterns = {
      creational: ['Singleton', 'Factory', 'Builder'],
      structural: ['Adapter', 'Decorator', 'Proxy'],
      behavioral: ['Observer', 'Strategy', 'Command']
    };
  }
}
```

### Q2: 如何实现单例模式？

**标准答案：**
确保一个类只有一个实例，并提供全局访问点。

**面试回答技巧：**
```javascript
// 单例模式实现
class Singleton {
  constructor() {
    if (Singleton.instance) {
      return Singleton.instance;
    }
    Singleton.instance = this;
    this.data = [];
  }

  addItem(item) {
    this.data.push(item);
  }

  getData() {
    return this.data;
  }

  static getInstance() {
    if (!Singleton.instance) {
      Singleton.instance = new Singleton();
    }
    return Singleton.instance;
  }
}

// 使用示例
const instance1 = new Singleton();
const instance2 = new Singleton();
console.log(instance1 === instance2); // true

// 模块化单例
const AppConfig = (function() {
  let instance;
  
  function createInstance() {
    return {
      apiUrl: 'https://api.example.com',
      timeout: 5000,
      retryCount: 3
    };
  }
  
  return {
    getInstance: function() {
      if (!instance) {
        instance = createInstance();
      }
      return instance;
    }
  };
})();
```

### Q3: 如何实现工厂模式？

**标准答案：**
通过工厂方法创建对象，而不直接使用new关键字。

**面试回答技巧：**
```javascript
// 工厂模式实现
class ButtonFactory {
  createButton(type) {
    switch (type) {
      case 'primary':
        return new PrimaryButton();
      case 'secondary':
        return new SecondaryButton();
      case 'danger':
        return new DangerButton();
      default:
        throw new Error(`Unknown button type: ${type}`);
    }
  }
}

class Button {
  render() {
    throw new Error('render method must be implemented');
  }
}

class PrimaryButton extends Button {
  render() {
    return '<button class="btn btn-primary">Primary</button>';
  }
}

class SecondaryButton extends Button {
  render() {
    return '<button class="btn btn-secondary">Secondary</button>';
  }
}

class DangerButton extends Button {
  render() {
    return '<button class="btn btn-danger">Danger</button>';
  }
}

// 使用示例
const factory = new ButtonFactory();
const primaryBtn = factory.createButton('primary');
const secondaryBtn = factory.createButton('secondary');

// 抽象工厂模式
class UIFactory {
  createButton() {
    throw new Error('createButton method must be implemented');
  }
  
  createInput() {
    throw new Error('createInput method must be implemented');
  }
}

class MaterialUIFactory extends UIFactory {
  createButton() {
    return new MaterialButton();
  }
  
  createInput() {
    return new MaterialInput();
  }
}

class BootstrapUIFactory extends UIFactory {
  createButton() {
    return new BootstrapButton();
  }
  
  createInput() {
    return new BootstrapInput();
  }
}
```

### Q4: 如何实现观察者模式？

**标准答案：**
定义对象间的一对多依赖关系，当一个对象状态改变时，所有依赖者都会收到通知。

**面试回答技巧：**
```javascript
// 观察者模式实现
class EventEmitter {
  constructor() {
    this.events = {};
  }

  on(event, callback) {
    if (!this.events[event]) {
      this.events[event] = [];
    }
    this.events[event].push(callback);
  }

  off(event, callback) {
    if (!this.events[event]) return;
    
    const index = this.events[event].indexOf(callback);
    if (index > -1) {
      this.events[event].splice(index, 1);
    }
  }

  emit(event, data) {
    if (!this.events[event]) return;
    
    this.events[event].forEach(callback => {
      callback(data);
    });
  }

  once(event, callback) {
    const onceCallback = (data) => {
      callback(data);
      this.off(event, onceCallback);
    };
    this.on(event, onceCallback);
  }
}

// 使用示例
const emitter = new EventEmitter();

emitter.on('userLogin', (user) => {
  console.log('User logged in:', user);
});

emitter.on('userLogout', (user) => {
  console.log('User logged out:', user);
});

emitter.emit('userLogin', { id: 1, name: 'John' });

// Vue.js风格的响应式系统
class Dep {
  constructor() {
    this.subscribers = new Set();
  }

  depend() {
    if (activeEffect) {
      this.subscribers.add(activeEffect);
    }
  }

  notify() {
    this.subscribers.forEach(effect => effect());
  }
}

let activeEffect = null;

function reactive(obj) {
  Object.keys(obj).forEach(key => {
    const dep = new Dep();
    let value = obj[key];
    
    Object.defineProperty(obj, key, {
      get() {
        dep.depend();
        return value;
      },
      set(newValue) {
        value = newValue;
        dep.notify();
      }
    });
  });
  
  return obj;
}

function watchEffect(effect) {
  activeEffect = effect;
  effect();
  activeEffect = null;
}
```

### Q5: 如何实现策略模式？

**标准答案：**
定义一系列算法，使它们可以互相替换，算法的变化不会影响使用算法的客户。

**面试回答技巧：**
```javascript
// 策略模式实现
class PaymentStrategy {
  pay(amount) {
    throw new Error('pay method must be implemented');
  }
}

class CreditCardStrategy extends PaymentStrategy {
  pay(amount) {
    console.log(`Paid $${amount} using Credit Card`);
  }
}

class PayPalStrategy extends PaymentStrategy {
  pay(amount) {
    console.log(`Paid $${amount} using PayPal`);
  }
}

class CryptoStrategy extends PaymentStrategy {
  pay(amount) {
    console.log(`Paid $${amount} using Cryptocurrency`);
  }
}

class ShoppingCart {
  constructor() {
    this.paymentStrategy = null;
  }

  setPaymentStrategy(strategy) {
    this.paymentStrategy = strategy;
  }

  checkout(amount) {
    if (!this.paymentStrategy) {
      throw new Error('Payment strategy not set');
    }
    this.paymentStrategy.pay(amount);
  }
}

// 使用示例
const cart = new ShoppingCart();
cart.setPaymentStrategy(new CreditCardStrategy());
cart.checkout(100);

// 表单验证策略
const validationStrategies = {
  required: (value) => value.length > 0 ? null : 'This field is required',
  email: (value) => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value) ? null : 'Invalid email format',
  minLength: (min) => (value) => value.length >= min ? null : `Minimum length is ${min}`,
  maxLength: (max) => (value) => value.length <= max ? null : `Maximum length is ${max}`
};

class FormValidator {
  constructor() {
    this.validators = [];
  }

  addValidator(validator) {
    this.validators.push(validator);
  }

  validate(value) {
    for (const validator of this.validators) {
      const error = validator(value);
      if (error) return error;
    }
    return null;
  }
}
```

### Q6: 如何实现装饰器模式？

**标准答案：**
动态地给对象添加新的功能，而不改变其结构。

**面试回答技巧：**
```javascript
// 装饰器模式实现
class Coffee {
  cost() {
    return 10;
  }

  description() {
    return 'Simple coffee';
  }
}

class CoffeeDecorator {
  constructor(coffee) {
    this.coffee = coffee;
  }

  cost() {
    return this.coffee.cost();
  }

  description() {
    return this.coffee.description();
  }
}

class MilkDecorator extends CoffeeDecorator {
  cost() {
    return this.coffee.cost() + 2;
  }

  description() {
    return this.coffee.description() + ', milk';
  }
}

class SugarDecorator extends CoffeeDecorator {
  cost() {
    return this.coffee.cost() + 1;
  }

  description() {
    return this.coffee.description() + ', sugar';
  }
}

// 使用示例
let coffee = new Coffee();
coffee = new MilkDecorator(coffee);
coffee = new SugarDecorator(coffee);

console.log(coffee.cost()); // 13
console.log(coffee.description()); // Simple coffee, milk, sugar

// 函数装饰器
function log(target, name, descriptor) {
  const original = descriptor.value;
  
  descriptor.value = function(...args) {
    console.log(`Calling ${name} with:`, args);
    const result = original.apply(this, args);
    console.log(`Result:`, result);
    return result;
  };
  
  return descriptor;
}

class Calculator {
  @log
  add(a, b) {
    return a + b;
  }
}

// 高阶函数装饰器
function memoize(fn) {
  const cache = new Map();
  
  return function(...args) {
    const key = JSON.stringify(args);
    if (cache.has(key)) {
      return cache.get(key);
    }
    
    const result = fn.apply(this, args);
    cache.set(key, result);
    return result;
  };
}

const expensiveFunction = memoize((n) => {
  console.log('Computing...');
  return n * 2;
});
```

### Q7: 如何实现适配器模式？

**标准答案：**
将一个类的接口转换成客户希望的另一个接口。

**面试回答技巧：**
```javascript
// 适配器模式实现
class OldAPI {
  getData() {
    return {
      user_id: 123,
      user_name: 'John Doe',
      user_email: 'john@example.com'
    };
  }
}

class NewAPI {
  getUser() {
    return {
      id: 456,
      name: 'Jane Smith',
      email: 'jane@example.com'
    };
  }
}

class UserAdapter {
  constructor(api) {
    this.api = api;
  }

  getData() {
    if (this.api instanceof OldAPI) {
      const data = this.api.getData();
      return {
        id: data.user_id,
        name: data.user_name,
        email: data.user_email
      };
    } else if (this.api instanceof NewAPI) {
      return this.api.getUser();
    }
  }
}

// 使用示例
const oldAPI = new OldAPI();
const newAPI = new NewAPI();

const oldAdapter = new UserAdapter(oldAPI);
const newAdapter = new UserAdapter(newAPI);

console.log(oldAdapter.getData()); // { id: 123, name: 'John Doe', email: 'john@example.com' }
console.log(newAdapter.getData()); // { id: 456, name: 'Jane Smith', email: 'jane@example.com' }

// 第三方库适配器
class jQueryAdapter {
  constructor(selector) {
    this.element = document.querySelector(selector);
  }

  on(event, handler) {
    this.element.addEventListener(event, handler);
  }

  off(event, handler) {
    this.element.removeEventListener(event, handler);
  }

  html(content) {
    if (content !== undefined) {
      this.element.innerHTML = content;
    }
    return this.element.innerHTML;
  }

  css(property, value) {
    if (value !== undefined) {
      this.element.style[property] = value;
    }
    return this.element.style[property];
  }
}

// 使用示例
const $ = (selector) => new jQueryAdapter(selector);
$('#button').on('click', () => console.log('clicked'));
$('#content').html('<p>Hello World</p>');
```

### Q8: 如何实现代理模式？

**标准答案：**
为其他对象提供一种代理以控制对这个对象的访问。

**面试回答技巧：**
```javascript
// 代理模式实现
class Image {
  constructor(filename) {
    this.filename = filename;
    this.load();
  }

  load() {
    console.log(`Loading image: ${this.filename}`);
  }

  display() {
    console.log(`Displaying image: ${this.filename}`);
  }
}

class ProxyImage {
  constructor(filename) {
    this.filename = filename;
    this.realImage = null;
  }

  display() {
    if (!this.realImage) {
      this.realImage = new Image(this.filename);
    }
    this.realImage.display();
  }
}

// 使用示例
const image = new ProxyImage('photo.jpg');
image.display(); // 第一次会加载图片
image.display(); // 第二次直接显示，不会重新加载

// 虚拟代理
class VirtualProxy {
  constructor(createFn) {
    this.createFn = createFn;
    this.instance = null;
  }

  getInstance() {
    if (!this.instance) {
      this.instance = this.createFn();
    }
    return this.instance;
  }
}

// 缓存代理
function createCacheProxy(fn) {
  const cache = new Map();
  
  return function(...args) {
    const key = JSON.stringify(args);
    if (cache.has(key)) {
      console.log('Returning cached result');
      return cache.get(key);
    }
    
    console.log('Computing result');
    const result = fn.apply(this, args);
    cache.set(key, result);
    return result;
  };
}

const expensiveOperation = createCacheProxy((a, b) => {
  // 模拟复杂计算
  return a + b;
});

// 保护代理
class ProtectedProxy {
  constructor(target) {
    this.target = target;
  }

  get(property) {
    if (property.startsWith('_')) {
      throw new Error(`Access denied to private property: ${property}`);
    }
    return this.target[property];
  }

  set(property, value) {
    if (property.startsWith('_')) {
      throw new Error(`Access denied to private property: ${property}`);
    }
    this.target[property] = value;
  }
}
```

## 🎯 面试技巧总结

### 回答策略

**1. 模式理解**
- 理解设计模式的核心思想和适用场景
- 能够分析模式的优缺点

**2. 代码实现**
- 展示清晰的代码实现
- 说明模式的应用场景

**3. 实际应用**
- 结合前端实际场景
- 展示模式的实际价值

### 加分点

1. **模式思维**：展示对设计模式的深入理解
2. **代码质量**：写出清晰、可维护的代码
3. **实际应用**：结合前端实际场景
4. **性能考虑**：考虑模式对性能的影响

### 常见误区

1. **过度设计**：不要为了使用模式而使用模式
2. **忽视性能**：要注意模式对性能的影响
3. **缺乏实践**：要有实际的应用经验
4. **不结合场景**：要结合具体的业务场景

### 面试准备清单

- [ ] 掌握常用设计模式的核心思想
- [ ] 理解模式的适用场景和优缺点
- [ ] 能够手写常见模式的实现
- [ ] 准备实际应用案例
- [ ] 了解模式对性能的影响

## 💡 总结

设计模式在前端开发中主要用于：
1. **代码组织**：提高代码的可维护性和可读性
2. **功能扩展**：动态添加新功能而不影响现有代码
3. **接口统一**：适配不同的API和库
4. **性能优化**：通过缓存、懒加载等模式优化性能

面试时要重点展示：
- 对设计模式原理的理解
- 清晰的代码实现能力
- 实际应用和问题解决能力
- 代码组织和架构设计能力 