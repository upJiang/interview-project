# 算法学习与面试准备指南

## 目录
- [算法基础](#算法基础)
- [面试应对策略](#面试应对策略)
- [常见算法类型及解题思路](#常见算法类型及解题思路)
  - [数组](#数组)
  - [链表](#链表)
  - [字符串](#字符串)
  - [递归和回溯](#递归和回溯)
  - [动态规划](#动态规划)
  - [排序算法](#排序算法)
  - [贪心算法](#贪心算法)
  - [树和图](#树和图)
  - [图搜索算法](#图搜索算法)
  - [数字格式化](#数字格式化)
- [复杂度分析](#复杂度分析)
- [面试中的常见陷阱](#面试中的常见陷阱)

## 算法基础

### 算法学习方法
1. **掌握核心数据结构**：数组、链表、栈、队列、哈希表、树、图等
2. **理解基本算法策略**：分治、递归、贪心、动态规划等
3. **刻意练习**：从简单题目开始，逐步提高难度
4. **总结模式**：识别题目类型，掌握对应解题模板
5. **手写代码**：不依赖IDE，培养编码能力

### 解题思路框架
1. **理解问题**：分析题目要求，澄清边界条件和特殊情况
2. **思考算法**：选择合适的数据结构和算法策略
3. **编写代码**：实现解决方案
4. **验证测试**：使用示例和边界情况测试
5. **优化方案**：分析时间和空间复杂度，寻找优化机会

## 面试应对策略

### 面试前准备
1. **系统复习**：按数据结构和算法类型复习
2. **模拟面试**：计时做题，口头解释思路
3. **整理常见题型**：按公司和岗位特点重点准备

### 面试中技巧
1. **思考有声**：边思考边解释，展示解题过程
2. **分析多种方法**：先给出简单解法，再优化
3. **沟通确认**：主动澄清问题细节和需求
4. **处理困难**：遇到难题不慌，从简单情况分析
5. **代码规范**：注意命名、边界处理、错误检查

### 解题步骤示例
1. **理解问题**
   ```
   "给我讲一下你对这个问题的理解..."
   "这个问题是要求..."
   "我想确认一下，输入是...输出应该是..."
   ```

2. **分析思路**
   ```
   "我们可以通过...方法解决这个问题"
   "首先考虑暴力解法..."
   "这个问题可以使用...数据结构优化"
   ```

3. **复杂度分析**
   ```
   "这个算法的时间复杂度是O(...)，因为..."
   "空间复杂度是O(...)，因为我们使用了..."
   ```

4. **代码实现**
   ```
   "现在我来实现这个算法..."
   "这里需要注意边界情况..."
   ```

5. **测试验证**
   ```
   "让我用示例测试一下..."
   "检查特殊情况：空输入/最大值/最小值..."
   ```

## 常见算法类型及解题思路

### 数组

#### 核心技巧
1. **双指针技巧**：解决查找、排序、子数组问题
2. **前缀和**：快速计算子数组和
3. **滑动窗口**：处理连续子数组/子串问题
4. **二分查找**：在有序数组中高效查找
5. **哈希表**：O(1)时间复杂度查找元素

#### 典型问题
- 两数之和/三数之和
- 合并有序数组
- 寻找缺失的第一个正数
- 数组去重
- 最大子数组和
- 滑动窗口最大值

### 链表

#### 核心技巧
1. **快慢指针**：检测环、找中点
2. **哨兵节点**：简化边界情况处理
3. **递归**：简洁解决链表问题
4. **迭代**：常用于就地修改链表
5. **双指针**：删除、合并等操作

#### 典型问题
- 链表反转
- 合并有序链表
- 删除链表中的节点
- 检测环形链表
- 链表排序
- 相交链表

### 字符串

#### 核心技巧
1. **双指针**：回文串判断
2. **哈希表**：字符统计和查找
3. **滑动窗口**：子串问题
4. **动态规划**：编辑距离类问题
5. **分治**：复杂字符串处理

#### 典型问题
- 字符串反转
- 回文串判断
- 最长不重复子串
- 字符串匹配（KMP算法）
- 括号匹配问题
- 数字千分位分割

### 递归和回溯

#### 核心技巧
1. **问题分解**：将大问题分解为小问题
2. **基础情况**：明确递归终止条件
3. **状态管理**：选择、探索、撤销选择
4. **剪枝**：提前结束无效搜索
5. **备忘录**：避免重复计算

#### 典型问题
- 全排列问题
- 子集问题
- N皇后问题
- 数组分组问题
- 路径搜索问题

### 动态规划

#### 核心技巧
1. **状态定义**：明确dp数组含义
2. **转移方程**：找到状态间关系
3. **初始化**：设置基础情况
4. **计算顺序**：自底向上或自顶向下
5. **空间优化**：减少维度、滚动数组

#### 典型问题
- 爬楼梯问题
- 最长递增子序列
- 编辑距离
- 背包问题系列
- 股票买卖问题
- 不相邻元素的最大和

### 排序算法

#### 常用排序算法
1. **冒泡排序**：O(n²)，稳定
2. **选择排序**：O(n²)，不稳定
3. **插入排序**：O(n²)，稳定
4. **快速排序**：O(nlogn)，不稳定
5. **归并排序**：O(nlogn)，稳定
6. **堆排序**：O(nlogn)，不稳定
7. **计数排序**：O(n+k)，稳定，适用于已知范围的整数

#### 特点和选择
- 小数据量：插入排序
- 稳定性要求高：归并排序
- 平均性能要求高：快速排序
- 空间限制严格：堆排序
- 整数且范围有限：计数排序

### 贪心算法

#### 核心思想
每一步选择当前最优解，期望最终得到全局最优解。

#### 典型问题
- 分发饼干问题
- 无重叠区间问题
- 活动选择问题
- 硬币找零问题
- 霍夫曼编码
- 最小生成树算法（Kruskal算法）

### 树和图

#### 核心技巧
1. **深度优先遍历(DFS)**：递归或栈实现
2. **广度优先遍历(BFS)**：队列实现
3. **二叉搜索树特性**：中序遍历有序
4. **平衡树概念**：维持较小高度
5. **图算法**：拓扑排序、最短路径等

#### 典型问题
- 二叉树遍历（前序、中序、后序）
- 二叉树层序遍历
- 二叉树的最大深度
- 验证二叉搜索树
- 最近公共祖先

### 图搜索算法

#### 深度优先搜索(DFS)
1. **实现方式**：
   - 递归实现：利用系统栈
   - 迭代实现：使用显式栈
2. **适用场景**：
   - 查找路径
   - 拓扑排序
   - 连通分量识别
   - 解决迷宫问题
3. **关键点**：
   - 标记已访问节点，避免死循环
   - 记录访问路径，确保正确回溯

#### 广度优先搜索(BFS)
1. **实现方式**：
   - 使用队列存储待访问节点
2. **适用场景**：
   - 寻找最短路径
   - 层次遍历
   - 寻找特定深度的节点
3. **关键点**：
   - 入队前标记节点为已访问，避免重复入队
   - 可以计算距离或层次信息

#### 图算法应用
1. **最短路径**：使用BFS寻找无权图最短路径
2. **连通分量**：使用DFS识别连通区域
3. **拓扑排序**：检测有向图是否有环，安排顺序
4. **路径查找**：确定两点间是否存在路径

### 数字格式化

#### 千分位分割
1. **实现方法**：
   - 正则表达式：简洁但需理解正则
   - 手动分割：直观但代码较长
   - Intl.NumberFormat：现代浏览器标准
2. **注意事项**：
   - 处理负数和小数点
   - 从右向左每三位添加分隔符

#### 科学计数法转换
1. **数字转科学计数法**：使用toExponential方法
2. **科学计数法转普通数字**：
   - 处理正指数情况(小数点右移)
   - 处理负指数情况(小数点左移)

#### 格式化应用
1. **货币格式化**：添加货币符号，控制小数位
2. **文件大小格式化**：如B, KB, MB, GB等单位转换
3. **数字缩写格式化**：如1.2k, 3.5M等
4. **中文数字格式化**：将数字转换为中文表示

## 复杂度分析

### 时间复杂度
- **O(1)**：常数时间
- **O(log n)**：对数时间（二分查找）
- **O(n)**：线性时间（遍历）
- **O(n log n)**：线性对数时间（排序）
- **O(n²)**：平方时间（嵌套循环）
- **O(2^n)**：指数时间（无优化的递归）
- **O(n!)**：阶乘时间（全排列）

### 空间复杂度
- **辅助空间**：算法执行过程中临时占用的空间
- **输入空间**：算法输入占用的空间
- **总空间复杂度**：辅助空间+输入空间

## 面试中的常见陷阱

1. **边界条件**：空输入、最大/最小值、单元素等
2. **整数溢出**：大数相加、相乘等
3. **指针错误**：空指针、野指针等
4. **死循环**：循环条件设置错误
5. **算法效率**：时间/空间复杂度过高
6. **代码冗余**：过度复杂的实现

## 新增算法实现总结

### 深度优先搜索与广度优先搜索
在图搜索算法中，DFS使用栈结构（可通过递归或显式栈实现）探索尽可能深的路径，适合寻找路径、拓扑排序等；BFS使用队列结构按层次扩展，适合寻找最短路径、层级遍历等。两种算法的关键都是正确标记已访问节点，避免死循环。

### 全排列算法
全排列算法通常使用回溯法实现，核心思想是不断选择、探索、撤销选择的过程。通过记录已使用的元素避免重复选择，对于包含重复元素的数组，需要排序并跳过相同数字的重复选择以避免生成重复排列。

### 数字格式化与分割
数字格式化有多种实现方式，如正则表达式（简洁)、手动分割（直观）和标准API（Intl.NumberFormat）。需要注意处理负数、小数部分、科学计数法的转换等特殊情况。格式化应用包括千分位分割、货币格式化、文件大小格式化等。

## 总结

算法面试不仅考察编码能力，更考察思维方式和解决问题的能力。通过系统学习和大量练习，掌握常见算法模式和解题技巧，提高解决问题的效率。面试中保持冷静，清晰表达思路，遇到困难不放弃，能够赢得面试官的好感。

记住：算法能力是日积月累的结果，持续学习和练习是成功的关键。 