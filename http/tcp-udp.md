# TCP 与 UDP

## TCP 简介

TCP(Transmission Control Protocol，传输控制协议)是一种面向连接、可靠的、基于字节流的传输层通信协议。

```javascript
function tcpIntroduction() {
  // TCP的主要特点:
  // - 面向连接：通信前需要建立连接，通信后需要释放连接
  // - 可靠传输：使用确认和重传机制确保数据无差错、不丢失、不重复、按顺序到达
  // - 流量控制：发送方根据接收方的处理能力调整发送速率
  // - 拥塞控制：根据网络状况调整发送速率
  // - 全双工通信：允许数据在两个方向上同时传输
  
  // TCP的应用场景:
  // - 网页浏览(HTTP/HTTPS)
  // - 电子邮件(SMTP, IMAP, POP3)
  // - 文件传输(FTP)
  // - 远程登录(SSH, Telnet)
  // - 数据库访问
  // - 任何需要可靠传输的应用
  
  // TCP头部结构(20-60字节):
  // - 源端口号(16位)
  // - 目标端口号(16位)
  // - 序列号(32位)
  // - 确认号(32位)
  // - 头部长度(4位)、保留(6位)、控制位(6位)
  // - 窗口大小(16位)
  // - 校验和(16位)
  // - 紧急指针(16位)
  // - 选项(可变长度)
}
```

## TCP 连接管理

TCP连接的建立、数据传输和终止过程是TCP协议的核心部分。

```javascript
function tcpConnectionManagement() {
  // TCP三次握手(建立连接):
  
  // 1. 客户端 -> 服务器: SYN包(seq=x)
  // - 客户端发送SYN标志位=1的TCP包
  // - 表示请求建立连接，并指定自己的初始序列号x
  
  // 2. 服务器 -> 客户端: SYN+ACK包(seq=y, ack=x+1)
  // - 服务器回复SYN标志位=1和ACK标志位=1的TCP包
  // - 确认收到客户端的请求，指定自己的初始序列号y
  // - 确认号ack=x+1表示期望收到客户端的下一个序列号
  
  // 3. 客户端 -> 服务器: ACK包(seq=x+1, ack=y+1)
  // - 客户端发送ACK标志位=1的TCP包
  // - 确认收到服务器的回复，连接建立成功
  
  // 为什么需要三次握手:
  // - 确保双方都能收发数据
  // - 避免历史连接请求突然到达导致的资源浪费
  // - 同步双方的初始序列号
  
  // TCP四次挥手(终止连接):
  
  // 1. 客户端 -> 服务器: FIN包(seq=u)
  // - 客户端发送FIN标志位=1的TCP包
  // - 表示客户端没有数据要发送了，请求关闭连接
  
  // 2. 服务器 -> 客户端: ACK包(seq=v, ack=u+1)
  // - 服务器回复ACK标志位=1的TCP包
  // - 确认收到客户端的关闭请求
  // - 此时客户端到服务器的连接关闭(半关闭状态)
  
  // 3. 服务器 -> 客户端: FIN包(seq=w, ack=u+1)
  // - 服务器发送FIN标志位=1的TCP包
  // - 表示服务器也没有数据要发送了，请求关闭连接
  
  // 4. 客户端 -> 服务器: ACK包(seq=u+1, ack=w+1)
  // - 客户端回复ACK标志位=1的TCP包
  // - 确认收到服务器的关闭请求
  // - 客户端进入TIME_WAIT状态，等待2MSL后完全关闭
  
  // 为什么需要四次挥手:
  // - 关闭连接是独立的操作，每个方向都需要单独关闭
  // - 服务器收到关闭请求后可能还有数据需要发送
  // - 确保所有在途数据都被正确处理
}
```

## TCP 可靠传输机制

TCP通过多种机制确保数据的可靠传输。

```javascript
function tcpReliableTransmission() {
  // TCP可靠传输的主要机制:
  
  // 1. 序列号与确认应答机制
  // - 每个TCP段都有序列号
  // - 接收方通过确认应答(ACK)表示已接收到数据
  // - 确认号表示期望接收的下一个字节序列号
  
  // 2. 超时重传机制
  // - 发送方在发送数据后启动定时器
  // - 如果在超时时间内没有收到确认，则重传数据
  // - 超时时间通常基于RTT(往返时间)动态调整
  
  // 3. 快速重传机制
  // - 接收方在收到失序的报文段后立即发送重复确认
  // - 发送方收到三个重复确认后立即重传，不等待超时
  // - 提高了重传的效率
  
  // 4. 选择性确认(SACK)
  // - 允许接收方确认不连续的数据块
  // - 发送方只需重传丢失的数据，不需要重传整个窗口
  // - 减少不必要的重传，提高传输效率
  
  // 5. 校验和
  // - 每个TCP段都包含校验和
  // - 用于检测传输过程中的数据错误
  // - 如果校验和不匹配，接收方会丢弃该段
}
```

## TCP 流量控制

TCP流量控制确保发送方不会发送太多数据，导致接收方缓冲区溢出。

```javascript
function tcpFlowControl() {
  // TCP流量控制机制:
  
  // 1. 滑动窗口机制
  // - 接收方通告自己的接收窗口大小(rwnd)
  // - 发送方根据接收窗口限制发送数据量
  // - 窗口大小会随着数据的收发动态调整
  
  // 2. 窗口调整过程
  // - 接收方处理数据并释放缓冲区空间
  // - 接收方通过确认报文更新窗口大小
  // - 发送方根据新的窗口大小调整发送速率
  
  // 3. 零窗口处理
  // - 当接收窗口为0时，发送方停止发送数据
  // - 发送方会定期发送窗口探测包询问接收方窗口状态
  // - 当接收方窗口重新变为非0时，继续发送数据
  
  // 4. 糊涂窗口综合症(Silly Window Syndrome)
  // - 问题：接收方只能接收很小的数据，导致传输效率低下
  // - 解决：接收方等待一定量的缓冲区空间才更新窗口
  // - 解决：发送方等待数据累积到一定量才发送
}
```

## TCP 拥塞控制

TCP拥塞控制用于应对网络拥塞，避免网络过载而导致的数据丢失。

```javascript
function tcpCongestionControl() {
  // TCP拥塞控制的四个算法:
  
  // 1. 慢启动(Slow Start)
  // - 连接初始阶段，拥塞窗口(cwnd)从1MSS开始
  // - 每收到一个确认，cwnd增加1MSS
  // - cwnd呈指数增长，直到达到慢启动阈值(ssthresh)
  
  // 2. 拥塞避免(Congestion Avoidance)
  // - 当cwnd >= ssthresh时进入拥塞避免阶段
  // - 每个RTT，cwnd只增加1MSS
  // - cwnd呈线性增长，增长速度变慢
  
  // 3. 快速重传(Fast Retransmit)
  // - 接收方收到失序数据后立即发送重复ACK
  // - 发送方收到3个重复ACK后立即重传，不等待超时
  
  // 4. 快速恢复(Fast Recovery)
  // - 收到3个重复ACK后，ssthresh设为cwnd的一半
  // - cwnd设为ssthresh+3MSS
  // - 每收到一个重复ACK，cwnd增加1MSS
  // - 当收到新的ACK后，cwnd设为ssthresh，进入拥塞避免阶段
  
  // 拥塞事件处理:
  // - 超时重传：表示严重拥塞，ssthresh=cwnd/2，cwnd=1MSS，进入慢启动
  // - 3个重复ACK：表示轻微拥塞，使用快速重传和快速恢复
  
  // TCP拥塞控制算法变种:
  // - TCP Tahoe: 只有慢启动和拥塞避免
  // - TCP Reno: 增加了快速重传和快速恢复
  // - TCP New Reno: 改进的快速恢复算法
  // - TCP CUBIC: 更适合高带宽高延迟网络的算法
  // - TCP BBR: 基于带宽和延迟的拥塞控制算法
}
```

## UDP 简介

UDP(User Datagram Protocol，用户数据报协议)是一种无连接的传输层协议，提供简单的、不可靠的数据传输服务。

```javascript
function udpIntroduction() {
  // UDP的主要特点:
  // - 无连接：不需要建立连接就可以直接发送数据
  // - 不可靠：不保证数据的可靠传输，可能丢失、重复或失序
  // - 简单高效：头部开销小，处理速度快
  // - 无拥塞控制：不会因为网络拥塞而降低发送速率
  // - 支持广播和多播：可以一对多传输
  
  // UDP的应用场景:
  // - 实时音视频通话(VoIP)
  // - 在线游戏
  // - DNS查询
  // - DHCP服务
  // - 流媒体传输
  // - 物联网设备通信
  // - 任何对实时性要求高、对可靠性要求低的应用
  
  // UDP头部结构(仅8字节):
  // - 源端口号(16位)
  // - 目标端口号(16位)
  // - 长度(16位)
  // - 校验和(16位)
}
```

## TCP 与 UDP 对比

TCP和UDP各有优缺点，适用于不同的应用场景。

```javascript
function tcpVsUdp() {
  // TCP与UDP的主要区别:
  
  // 1. 连接
  // - TCP: 面向连接，需要建立连接才能通信
  // - UDP: 无连接，可以直接发送数据
  
  // 2. 可靠性
  // - TCP: 可靠传输，保证数据无差错、不丢失、不重复、按顺序到达
  // - UDP: 不可靠传输，不保证数据到达，可能丢失、重复或失序
  
  // 3. 传输方式
  // - TCP: 面向字节流，数据无边界
  // - UDP: 面向报文，保留数据边界
  
  // 4. 控制机制
  // - TCP: 拥塞控制、流量控制、差错控制
  // - UDP: 几乎没有控制机制
  
  // 5. 头部开销
  // - TCP: 头部20-60字节
  // - UDP: 头部仅8字节
  
  // 6. 传输速度
  // - TCP: 由于控制机制复杂，传输速度相对较慢
  // - UDP: 控制机制简单，传输速度快
  
  // 7. 应用场景
  // - TCP: 要求数据完整性和可靠性的应用
  // - UDP: 要求实时性、允许少量数据丢失的应用
  
  // 如何选择TCP还是UDP:
  // - 对数据完整性要求高：选TCP
  // - 对实时性要求高：选UDP
  // - 网络状况较差：选TCP
  // - 资源有限(如物联网设备)：可能选UDP
  // - 需要广播/多播：选UDP
}
```

## 常见面试题

1. 详细解释TCP三次握手和四次挥手的过程及原因。
2. TCP如何保证可靠传输？请列举几种机制并解释。
3. TCP和UDP的主要区别是什么？各自适用于哪些场景？
4. 简述TCP的拥塞控制算法。
5. 为什么TCP连接关闭需要四次挥手而不是三次？ 