# 微信小程序分包加载

本文件介绍小程序分包策略与优化

## 1. 分包加载概述

小程序分包加载是将小程序划分为不同的子包，在需要时按需加载，
可以优化小程序的启动速度和运行性能。分包加载使小程序突破了2M的主包大小限制，
整体代码包体积上限为20M，极大提升了小程序的承载能力。

## 2. 为什么需要分包

### 分包加载的必要性

1. **体积限制**
   - 小程序单个代码包最大2M
   - 超过2M无法上传发布
   - 通过分包可将代码包拆分，总体积上限20M

2. **首次启动性能**
   - 完整加载全部代码会导致启动缓慢
   - 分包后首次只需下载主包，启动更快
   - 子包按需加载，提升用户体验

3. **多团队协作**
   - 不同业务模块可独立开发和维护
   - 各团队负责自己的分包
   - 降低代码冲突和耦合

4. **灵活更新**
   - 子包可以独立更新，不影响主包
   - 降低更新影响范围
   - 便于进行局部调整

5. **资源合理分配**
   - 将核心功能放入主包，保证快速启动
   - 非核心功能放入子包，按需加载
   - 优化内存占用和网络请求

## 3. 分包的基本概念

### 分包类型

1. **主包**
   - 包含启动页面和TabBar页面
   - 包含公共资源和组件
   - 首次启动时必定下载

2. **普通分包**
   - 根据业务划分的子包
   - 用户进入对应页面时加载
   - 加载完成后一直保留在内存中

3. **独立分包**
   - 特殊类型的分包，可独立于主包运行
   - 不依赖主包即可运行
   - 用户访问时，如主包未下载则不下载主包

4. **分包预下载**
   - 进入某个页面时预先下载可能需要的分包
   - 提前下载，避免用户等待
   - 可配置预下载策略

### 分包特点
- 总大小上限: 单个小程序20M
- 单个分包上限: 2M
- 分包加载顺序: 主包 -> 需要的分包
- 独立分包与主包是并行关系
- 分包之间不能相互引用私有资源
- 公共资源放入主包可被所有分包访问

## 4. 分包配置方法

### 分包配置示例
在app.json中进行配置：

```json
{
  "pages": [
    "pages/index/index",
    "pages/logs/logs"
  ],
  "subpackages": [
    {
      "root": "packageA",
      "name": "packA", // 可选，分包别名
      "pages": [
        "pages/cat/cat",
        "pages/dog/dog"
      ]
    },
    {
      "root": "packageB",
      "name": "packB",
      "pages": [
        "pages/apple/apple",
        "pages/banana/banana"
      ],
      "independent": true // 声明为独立分包
    }
  ],
  "preloadRule": {
    "pages/index/index": {
      "network": "all", // 网络类型 all/wifi
      "packages": ["packB"] // 进入index页面时预下载packB
    }
  }
}
```

### 目录结构示例

```
project
├── app.js
├── app.json
├── app.wxss
├── pages            // 主包
│   ├── index
│   └── logs
├── packageA         // 分包A
│   └── pages
│       ├── cat
│       └── dog
└── packageB         // 分包B（独立分包）
    └── pages
        ├── apple
        └── banana
```

### 页面路径规则
- 主包页面路径: /pages/index/index
- 分包页面路径: /packageA/pages/cat/cat

### 分包引用原则
- 主包能访问主包资源
- 分包能访问主包资源
- 分包不能访问其他分包资源
- 独立分包不依赖主包就可运行

## 5. 分包预加载策略

### 预加载配置
在app.json中配置预加载规则：

```json
{
  "preloadRule": {
    "pages/index/index": {
      "network": "all",
      "packages": ["packageA"]
    },
    "pages/logs/logs": {
      "network": "wifi",
      "packages": ["packageB", "packageC"]
    }
  }
}
```

### 预加载策略

1. **根据用户行为预测**
   - 分析用户访问路径
   - 将高频访问的页面所在分包预加载

2. **根据网络环境调整**
   - WiFi环境可预加载更多资源
   - 移动网络谨慎预加载，避免消耗流量

3. **按优先级设置**
   - 核心功能分包优先加载
   - 非关键功能在空闲时加载

4. **根据页面关联性**
   - A页面打开后大概率会访问B页面
   - 进入A页面时预加载包含B页面的分包

5. **预加载限制**
   - 同一个分包在不同场景下的预下载规则会合并取最高优先级
   - 大量预加载会影响性能，需权衡利弊
   - 微信对预加载有一定限制，避免滥用

## 6. 独立分包详解

### 独立分包特性
- 可单独进入，不依赖主包
- 适合临时/活动/很少访问的功能
- 独立运行，独立加载

### 独立分包配置

```json
{
  "subpackages": [
    {
      "root": "independentPackage",
      "pages": [
        "pages/activity/activity"
      ],
      "independent": true
    }
  ]
}
```

### 独立分包适用场景
- 临时活动页面
- 不常使用的功能模块
- 体积较大的特殊功能

### 独立分包注意事项
- 不能依赖主包中的资源
- 需要包含所有运行所需资源
- 用户从普通分包打开独立分包，主包仍会被下载

## 7. 分包优化策略

### 主包优化
- 只保留必要页面（首页和TabBar页面）
- 将非必要组件和页面移至分包
- 优化主包资源，减少体积

### 分包划分建议
- 按功能模块划分分包
- 保持每个分包体积合理（控制在1.5M以内）
- 考虑访问频率和加载时机

### 资源处理
- 公共组件和工具放入主包
- 分包私有资源存放在分包内
- 图片等静态资源优先使用CDN

### 性能监控
- 监控各分包加载时间
- 收集用户等待反馈
- 持续优化分包策略

## 8. 常见问题与解决方案

### 分包体积超限
- 分析分包内容，移除不必要资源
- 将大型静态资源移至CDN
- 分包再拆分，优化结构

### 分包加载耗时长
- 添加加载提示UI
- 优化资源大小
- 调整预加载策略
- 使用独立分包减少依赖

### 分包间资源共享
- 将共享资源移至主包
- 使用动态引入特性（异步分包）
- 避免重复资源引入

### 跨分包通信
- 通过全局变量或本地存储共享数据
- 使用事件机制进行通知
- 统一数据管理

## 9. 分包加载监控

```javascript
function subpackageMonitoring() {
  // 监控分包加载性能，及时发现和解决问题
  
  // 1. 使用小程序自带的性能分析工具
  // - 微信开发者工具 -> 工具 -> 性能分析
  // - 查看分包加载时间
  // - 分析主包和分包体积
  // - 监控页面切换性能
  
  // 2. 自定义监控逻辑
  // 记录分包加载时间
  /*
  // 在页面onLoad前记录开始时间
  const startTime = Date.now();
  
  // 页面onReady时计算加载耗时
  Page({
    onLoad() {
      this.startTime = Date.now();
    },
    onReady() {
      const loadTime = Date.now() - this.startTime;
      console.log(`页面加载耗时: ${loadTime}ms`);
      
      // 上报加载时间
      wx.reportAnalytics('page_load_time', {
        page: 'pages/index/index',
        time: loadTime
      });
    }
  });
  */
  
  // 3. 使用wx.onAppShow和wx.onAppHide监控冷启动和热启动
  /*
  // app.js
  App({
    onLaunch(options) {
      // 记录启动时间
      this.launchTime = Date.now();
    },
    onShow(options) {
      // 启动类型: 冷启动 or 热启动
      const isColdStart = !this.hasShown;
      this.hasShown = true;
      
      const startTime = isColdStart ? this.launchTime : Date.now();
      
      // 首屏渲染完成时上报
      this.onFirstRenderDone = () => {
        const renderTime = Date.now() - startTime;
        console.log(`${isColdStart ? '冷启动' : '热启动'}耗时: ${renderTime}ms`);
        
        // 上报启动性能数据
        wx.reportAnalytics('app_start_time', {
          type: isColdStart ? 'cold' : 'hot',
          time: renderTime
        });
      };
    }
  });
  
  // 首页index.js
  Page({
    onReady() {
      const app = getApp();
      if (app.onFirstRenderDone) {
        app.onFirstRenderDone();
      }
    }
  });
  */
  
  // 4. 监控关键指标
  // - 主包加载时间
  // - 分包加载时间
  // - 页面切换时间
  // - 冷启动和热启动时间
  // - 预下载是否命中
  // - 独立分包启动时间
  
  // 5. 设置性能阈值告警
  // - 主包加载超过1000ms告警
  // - 分包加载超过800ms告警
  // - 页面切换超过300ms告警
  // - 冷启动超过3000ms告警
  // - 热启动超过1000ms告警
}
```

## 10. 分包加载最佳实践

```javascript
function bestPractices() {
  // 1. 主包精简原则
  // - 只包含首页必需资源
  // - TabBar页面必须在主包
  // - 公共组件和工具放主包
  // - 首屏渲染必需资源放主包
  
  // 2. 分包合理规划
  // - 按业务划分，相关功能放一起
  // - 低频功能放独立分包
  // - 活动页面放独立分包
  // - 控制单个分包大小不超过1.5M
  
  // 3. 预加载策略
  // - 首页预加载最常用的1-2个分包
  // - 弱网环境谨慎预加载
  // - 在页面切换前预加载目标页面分包
  
  // 4. 避免常见错误
  // - 避免分包间循环依赖
  // - 不在分包中放主包已有的资源
  // - 不滥用独立分包(会导致主包无法复用)
  // - 避免过多分包(增加维护成本)
  
  // 5. 定期优化
  // - 持续监控分包大小变化
  // - 定期清理冗余资源
  // - 根据用户行为调整分包结构
  // - 低频分包考虑迁移到云函数
}
```

## 11. 分包加载故障排查

```javascript
function troubleshooting() {
  // 常见问题及解决方案:
  
  // 1. 分包加载失败
  // 现象: 进入分包页面时报错或白屏
  // 解决:
  // - 检查网络连接
  // - 检查分包配置是否正确
  // - 检查分包路径是否存在
  // - 重新编译和上传代码
  
  // 2. 分包体积过大
  // 现象: 编译警告分包超过限制
  // 解决:
  // - 分析分包内大文件
  // - 压缩图片资源
  // - 拆分过大分包
  // - 移除不必要的依赖
  
  // 3. 分包加载过慢
  // 现象: 页面切换卡顿，加载时间长
  // 解决:
  // - 优化分包大小
  // - 检查并优化资源文件
  // - 调整预加载策略
  // - CDN加速静态资源
  
  // 4. 主包体积超限
  // 现象: 上传失败，提示主包超过2M
  // 解决:
  // - 将非必要组件移至分包
  // - 压缩资源文件
  // - 使用代码压缩和混淆
  // - 检查未使用的冗余代码
  
  // 5. 分包间资源引用错误
  // 现象: 报错找不到某资源
  // 解决:
  // - 检查引用路径是否正确
  // - 确保不跨分包引用私有资源
  // - 共享资源移至主包
  // - 独立分包确保资源自包含
  
  // 6. 调试技巧
  // - 使用微信开发者工具"分包详情"
  // - 查看Network面板加载情况
  // - 使用Console查看报错信息
  // - 构建npm后查看构建详情
}
```

## 常见面试题

1. 什么是小程序分包加载，有什么优势？
2. 小程序分包有哪几种类型？各有什么特点？
3. 独立分包和普通分包有什么区别？
4. 如何优化小程序的分包策略？
5. 分包预加载的最佳实践是什么？
6. 如何减小主包体积？
7. 分包间如何通信？
8. 独立分包的适用场景有哪些？
9. 小程序分包的大小限制是多少？
10. 如何监控分包加载性能？ 