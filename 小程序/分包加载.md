# 微信小程序分包加载

本文件介绍小程序分包策略与优化

## 1. 分包加载概述

小程序分包加载是将小程序划分为不同的子包，在需要时按需加载，
可以优化小程序的启动速度和运行性能。分包加载使小程序突破了2M的主包大小限制，
整体代码包体积上限为20M，极大提升了小程序的承载能力。

## 2. 为什么需要分包

```javascript
function whySubpackage() {
  // 分包加载的必要性:
  // 1. 体积限制
  // - 小程序单个代码包最大2M
  // - 超过2M无法上传发布
  // - 通过分包可将代码包拆分，总体积上限20M
  // 2. 首次启动性能
  // - 完整加载全部代码会导致启动缓慢
  // - 分包后首次只需下载主包，启动更快
  // - 子包按需加载，提升用户体验
  // 3. 多团队协作
  // - 不同业务模块可独立开发和维护
  // - 各团队负责自己的分包
  // - 降低代码冲突和耦合
  // 4. 灵活更新
  // - 子包可以独立更新，不影响主包
  // - 降低更新影响范围
  // - 便于进行局部调整
  // 5. 资源合理分配
  // - 将核心功能放入主包，保证快速启动
  // - 非核心功能放入子包，按需加载
  // - 优化内存占用和网络请求
}
```

## 3. 分包的基本概念

```javascript
function subpackageBasics() {
  // 分包类型:
  // 1. 主包:
  // - 包含启动页面和TabBar页面
  // - 包含公共资源和组件
  // - 首次启动时必定下载
  // 2. 普通分包:
  // - 根据业务划分的子包
  // - 用户进入对应页面时加载
  // - 加载完成后一直保留在内存中
  // 3. 独立分包:
  // - 特殊类型的分包，可独立于主包运行
  // - 不依赖主包即可运行
  // - 用户访问时，如主包未下载则不下载主包
  // 4. 分包预下载:
  // - 进入某个页面时预先下载可能需要的分包
  // - 提前下载，避免用户等待
  // - 可配置预下载策略
  // 分包特点:
  // - 总大小上限: 单个小程序20M
  // - 单个分包上限: 2M
  // - 分包加载顺序: 主包 -> 需要的分包
  // - 独立分包与主包是并行关系
  // - 分包之间不能相互引用私有资源
  // - 公共资源放入主包可被所有分包访问
}
```

## 4. 分包配置方法

```javascript
function subpackageConfiguration() {
  // 分包配置在app.json中进行:
  /*
  // app.json 分包配置示例
  {
    "pages": [
      "pages/index/index",
      "pages/logs/logs"
    ],
    "subpackages": [
      {
        "root": "packageA",
        "name": "packA", // 可选，分包别名
        "pages": [
          "pages/cat/cat",
          "pages/dog/dog"
        ]
      },
      {
        "root": "packageB",
        "name": "packB",
        "pages": [
          "pages/apple/apple",
          "pages/banana/banana"
        ],
        "independent": true // 声明为独立分包
      }
    ],
    "preloadRule": {
      "pages/index/index": {
        "network": "all", // 网络类型 all/wifi
        "packages": ["packB"] // 进入index页面时预下载packB
      }
    }
  }
  */
  // 目录结构示例:
  /*
  project
  ├── app.js
  ├── app.json
  ├── app.wxss
  ├── pages            // 主包
  │   ├── index
  │   └── logs
  ├── packageA         // 分包A
  │   └── pages
  │       ├── cat
  │       └── dog
  └── packageB         // 分包B（独立分包）
      └── pages
          ├── apple
          └── banana
  */
  // 页面路径规则:
  // - 主包页面路径: /pages/index/index
  // - 分包页面路径: /packageA/pages/cat/cat
  // 分包引用原则:
  // - 主包能访问主包资源
  // - 分包能访问主包资源
  // - 分包不能访问其他分包资源
  // - 独立分包不依赖主包就可运行
}
```

## 5. 分包预加载策略

```javascript
function preloadStrategy() {
  // 预加载配置:
  /*
  // app.json 预加载配置
  {
    "preloadRule": {
      "pages/index/index": {
        "network": "all",
        "packages": ["packageA"]
      },
      "pages/logs/logs": {
        "network": "wifi",
        "packages": ["packageB", "packageC"]
      }
    }
  }
  */
  // 预加载策略:
  // 1. 根据用户行为预测
  // - 分析用户访问路径
  // - 将高频访问的页面所在分包预加载
  // 2. 根据网络环境调整
  // - WiFi环境可预加载更多资源
  // - 移动网络谨慎预加载，避免消耗流量
  // 3. 按优先级设置
  // - 核心功能分包优先加载
  // - 非关键功能在空闲时加载
  // 4. 根据页面关联性
  // - A页面打开后大概率会访问B页面
  // - 进入A页面时预加载包含B页面的分包
  // 5. 预加载限制
  // - 同一个分包在不同场景下的预下载规则会合并取最高优先级
  // - 大量预加载会影响性能，需权衡利弊
  // - 微信对预加载有一定限制，避免滥用
}
```

## 6. 独立分包详解

```javascript
function independentPackage() {
  // 独立分包特性:
  // - 可单独进入，不依赖主包
  // - 适合临时/活动/很少访问的功能
  // - 独立运行，独立加载
  // 独立分包配置:
  /*
  // app.json
  {
    "subpackages": [
      {
        "root": "independentPackage",
        "pages": [
          "pages/activity/activity"
        ],
        "independent": true
      }
    ]
  }
  */
  // 独立分包适用场景:
  // - 临时活动页面
  // - 很少被访问的功能
  // - 需要快速启动的页面
  // - 独立运营的业务模块
  // 独立分包限制:
  // - 不能依赖主包中的公共资源
  // - 需要自包含所有需要的资源
  // - tabBar 页面不能做成独立分包
  // 独立分包运行机制:
  // 1. 从独立分包页面启动小程序
  // 2. 先加载和运行独立分包
  // 3. 同时在后台下载主包
  // 4. 如果用户访问主包页面，才会加载主包
  // 独立分包通信:
  // - 与主包通信需要考虑主包可能尚未加载
  // - 使用本地存储或云开发实现数据共享
  // - 独立分包内应当实现完整的用户体验
}
```

## 7. 分包优化策略

```javascript
function optimizationStrategies() {
  // 1. 代码优化:
  // - 合理拆分业务代码
  // - 减少冗余和重复资源
  // - 移除未使用代码
  // 2. 资源优化:
  // - 压缩图片资源(tinypng等)
  // - 使用适当格式(webp优于jpg/png)
  // - SVG替代简单图标
  // - iconfont替代图标图片
  // 3. 依赖优化:
  // - 避免引入过大的第三方库
  // - 精简npm包，使用小程序定制版
  // - 公共库放入主包，避免重复打包
  // - 使用分包异步化加载npm包
  // 4. 主包优化:
  // - 主包只包含必要组件和页面
  // - 首页所需资源优先级最高
  // - 核心流程相关功能放入主包
  // - 非必要功能迁移到分包
  // 5. 分包划分策略:
  // - 按业务模块划分
  // - 按使用频率划分
  // - 按功能相关性划分
  // - 时效性内容单独分包
}
```

## 8. 分包异步化

```javascript
function asyncSubpackage() {
  // 分包异步化是小程序基础库2.7.3引入的特性
  // 通过异步化组件和异步化接口，减少主包体积
  
  // 1. 异步化组件引用
  // 普通组件引用
  /*
  // 直接引用必须在主包打包此组件
  {
    "usingComponents": {
      "custom-component": "/components/custom-component/index"
    }
  }
  */
  
  // 异步化引用
  /*
  // 异步引用可将组件代码放入分包
  {
    "usingComponents": {
      "custom-component": "async://packageName/components/custom-component/index"
    }
  }
  */
  // async://前缀告诉编译器这是异步组件
  // packageName指定组件所在分包
  
  // 2. 异步化接口调用
  // 将定义在分包中的方法异步调用，无需将方法所在JS放入主包
  // 通过实例获取异步接口
  /*
  // 分包中定义函数
  // /packageA/utils/util.js
  export function someMethod() {
    // ...
  }
  
  // 主包中调用分包函数
  // 使用requirePlugin获取分包内导出函数
  const someMethod = requirePlugin('packageA/utils/util', 'someMethod');
  someMethod().then(res => {
    // 处理结果
  });
  */
  
  // 3. 异步化的注意事项
  // - 异步组件初次引用有加载延迟
  // - 被异步引用的组件不应再使用selectComponent直接访问
  // - 确保异步组件所在分包正确配置
  // - 异步接口调用需要Promise处理
  // - 避免异步组件之间的复杂依赖关系
}
```

## 9. 分包加载监控

```javascript
function subpackageMonitoring() {
  // 监控分包加载性能，及时发现和解决问题
  
  // 1. 使用小程序自带的性能分析工具
  // - 微信开发者工具 -> 工具 -> 性能分析
  // - 查看分包加载时间
  // - 分析主包和分包体积
  // - 监控页面切换性能
  
  // 2. 自定义监控逻辑
  // 记录分包加载时间
  /*
  // 在页面onLoad前记录开始时间
  const startTime = Date.now();
  
  // 页面onReady时计算加载耗时
  Page({
    onLoad() {
      this.startTime = Date.now();
    },
    onReady() {
      const loadTime = Date.now() - this.startTime;
      console.log(`页面加载耗时: ${loadTime}ms`);
      
      // 上报加载时间
      wx.reportAnalytics('page_load_time', {
        page: 'pages/index/index',
        time: loadTime
      });
    }
  });
  */
  
  // 3. 使用wx.onAppShow和wx.onAppHide监控冷启动和热启动
  /*
  // app.js
  App({
    onLaunch(options) {
      // 记录启动时间
      this.launchTime = Date.now();
    },
    onShow(options) {
      // 启动类型: 冷启动 or 热启动
      const isColdStart = !this.hasShown;
      this.hasShown = true;
      
      const startTime = isColdStart ? this.launchTime : Date.now();
      
      // 首屏渲染完成时上报
      this.onFirstRenderDone = () => {
        const renderTime = Date.now() - startTime;
        console.log(`${isColdStart ? '冷启动' : '热启动'}耗时: ${renderTime}ms`);
        
        // 上报启动性能数据
        wx.reportAnalytics('app_start_time', {
          type: isColdStart ? 'cold' : 'hot',
          time: renderTime
        });
      };
    }
  });
  
  // 首页index.js
  Page({
    onReady() {
      const app = getApp();
      if (app.onFirstRenderDone) {
        app.onFirstRenderDone();
      }
    }
  });
  */
  
  // 4. 监控关键指标
  // - 主包加载时间
  // - 分包加载时间
  // - 页面切换时间
  // - 冷启动和热启动时间
  // - 预下载是否命中
  // - 独立分包启动时间
  
  // 5. 设置性能阈值告警
  // - 主包加载超过1000ms告警
  // - 分包加载超过800ms告警
  // - 页面切换超过300ms告警
  // - 冷启动超过3000ms告警
  // - 热启动超过1000ms告警
}
```

## 10. 分包加载最佳实践

```javascript
function bestPractices() {
  // 1. 主包精简原则
  // - 只包含首页必需资源
  // - TabBar页面必须在主包
  // - 公共组件和工具放主包
  // - 首屏渲染必需资源放主包
  
  // 2. 分包合理规划
  // - 按业务划分，相关功能放一起
  // - 低频功能放独立分包
  // - 活动页面放独立分包
  // - 控制单个分包大小不超过1.5M
  
  // 3. 预加载策略
  // - 首页预加载最常用的1-2个分包
  // - 弱网环境谨慎预加载
  // - 在页面切换前预加载目标页面分包
  
  // 4. 避免常见错误
  // - 避免分包间循环依赖
  // - 不在分包中放主包已有的资源
  // - 不滥用独立分包(会导致主包无法复用)
  // - 避免过多分包(增加维护成本)
  
  // 5. 定期优化
  // - 持续监控分包大小变化
  // - 定期清理冗余资源
  // - 根据用户行为调整分包结构
  // - 低频分包考虑迁移到云函数
}
```

## 11. 分包加载故障排查

```javascript
function troubleshooting() {
  // 常见问题及解决方案:
  
  // 1. 分包加载失败
  // 现象: 进入分包页面时报错或白屏
  // 解决:
  // - 检查网络连接
  // - 检查分包配置是否正确
  // - 检查分包路径是否存在
  // - 重新编译和上传代码
  
  // 2. 分包体积过大
  // 现象: 编译警告分包超过限制
  // 解决:
  // - 分析分包内大文件
  // - 压缩图片资源
  // - 拆分过大分包
  // - 移除不必要的依赖
  
  // 3. 分包加载过慢
  // 现象: 页面切换卡顿，加载时间长
  // 解决:
  // - 优化分包大小
  // - 检查并优化资源文件
  // - 调整预加载策略
  // - CDN加速静态资源
  
  // 4. 主包体积超限
  // 现象: 上传失败，提示主包超过2M
  // 解决:
  // - 将非必要组件移至分包
  // - 压缩资源文件
  // - 使用代码压缩和混淆
  // - 检查未使用的冗余代码
  
  // 5. 分包间资源引用错误
  // 现象: 报错找不到某资源
  // 解决:
  // - 检查引用路径是否正确
  // - 确保不跨分包引用私有资源
  // - 共享资源移至主包
  // - 独立分包确保资源自包含
  
  // 6. 调试技巧
  // - 使用微信开发者工具"分包详情"
  // - 查看Network面板加载情况
  // - 使用Console查看报错信息
  // - 构建npm后查看构建详情
}
```

## 常见面试题

1. 什么是小程序分包加载，有什么优势？
2. 小程序分包有哪几种类型？各有什么特点？
3. 独立分包和普通分包有什么区别？
4. 如何优化小程序的分包策略？
5. 分包预加载的最佳实践是什么？
6. 如何减小主包体积？
7. 分包间如何通信？
8. 独立分包的适用场景有哪些？
9. 小程序分包的大小限制是多少？
10. 如何监控分包加载性能？ 