# 微信小程序性能优化

本文件涵盖：
1. 启动性能优化
2. 渲染性能优化
3. 网络请求优化
4. 内存优化
5. 常见面试题

## 1. 启动性能优化

启动性能优化：提升小程序冷启动和热启动的速度

影响启动性能的因素：
1. 代码包大小
2. 首屏资源加载
3. 初始化逻辑复杂度
4. 网络请求数量和速度

### 主包瘦身策略

```javascript
function reduceMainPackageSize() {
  // 1. 分包加载
  // 将非首屏页面和功能迁移到分包，保持主包精简
  // app.json 配置示例
  const appJson = {
    pages: [
      "pages/index/index", // 首页保留在主包
      "pages/user/profile", // 用户中心保留在主包
    ],
    subpackages: [
      {
        root: "packageA",
        pages: ["pages/feature1/index", "pages/feature2/index"],
      },
      {
        root: "packageB",
        name: "independent", // 命名方便管理
        pages: ["pages/rarely-used/index"],
        independent: true, // 独立分包，可单独加载不依赖主包
      },
    ],
  };

  // 2. 图片资源优化
  // 将主包中的图片移至CDN，通过网络请求加载
  // 使用压缩后的小图片作为占位，优先展示
  // 图片懒加载示例
  function lazyLoadImage() {
    this.setData({
      imageUrl: "https://cdn.example.com/large-image.jpg", // 从CDN加载
      placeholderUrl: "/images/placeholder-tiny.jpg", // 本地小图片占位
    });
  }

  // 3. 移除未使用代码和资源
  // 使用工具分析依赖，移除未使用的库和资源
  // 使用Tree Shaking减少无用代码
  // 举例：多余的npm包、未使用的组件等

  // 4. 使用适合的图片格式和尺寸
  // WebP > PNG/JPG
  // 根据实际显示尺寸提供适合的图片，避免过大

  // 5. 移除console.log
  // 生产环境移除调试代码，降低包体积和运行时消耗
}
```

### 启动逻辑优化

```javascript
function optimizeAppLaunch() {
  // 1. 延迟非关键任务
  // App实例中示例代码
  App({
    onLaunch: function () {
      // 必要的初始化放在onLaunch中
      this.initCore();

      // 非必要初始化延迟执行
      setTimeout(() => {
        this.initNonCritical();
      }, 3000);
    },

    // 核心初始化（保留在启动阶段）
    initCore: function () {
      // 登录、授权、核心数据加载等
      this.checkSession();
      this.initHomepageData();
    },

    // 非关键初始化（延迟执行）
    initNonCritical: function () {
      // 统计、插件加载、非关键配置等
      this.loadPlugins();
      this.initAnalytics();
      this.checkUpdate();
    },
  });

  // 2. 避免启动时同步API调用阻塞
  // 错误示例：使用同步API
  function wrongWay() {
    const token = wx.getStorageSync("token"); // 同步API会阻塞
    const userInfo = wx.getStorageSync("userInfo");
  }

  // 正确示例：使用异步API
  function rightWay() {
    Promise.all([
      new Promise((resolve) => {
        wx.getStorage({
          key: "token",
          success: (res) => resolve(res.data),
          fail: () => resolve(null),
        });
      }),
      new Promise((resolve) => {
        wx.getStorage({
          key: "userInfo",
          success: (res) => resolve(res.data),
          fail: () => resolve(null),
        });
      }),
    ]).then(([token, userInfo]) => {
      // 处理获取的数据
    });
  }

  // 3. 首屏关键请求优化
  // - 必要时使用本地缓存数据先展示
  // - 并行请求而非串行
  // - 优先级排序，核心数据先请求

  // 4. 预加载分包
  // 配置预加载规则，提前加载可能用到的分包
  const preloadRule = {
    "pages/index/index": {
      network: "all", // wifi或所有网络环境下都预加载
      packages: ["packageA"], // 预加载的分包名
    },
  };
}
```

## 2. 渲染性能优化

渲染性能优化：提高页面渲染速度，降低卡顿

影响渲染性能的因素：
1. setData频率和数据量
2. 页面结构复杂度
3. 重渲染频率
4. 复杂计算

### setData优化

```javascript
function optimizeSetData() {
  // 1. 减少setData次数
  // 错误示例：频繁多次setData
  function wrongWay() {
    this.setData({ a: 1 });
    this.setData({ b: 2 });
    this.setData({ c: 3 });
  }

  // 正确示例：合并setData调用
  function rightWay() {
    this.setData({
      a: 1,
      b: 2,
      c: 3,
    });
  }

  // 2. 仅更新必要数据
  // 错误示例：更新整个大对象
  function wrongWay() {
    // 假设list是一个有100项的大数组
    this.setData({
      list: this.data.list, // 更新整个list
    });
  }

  // 正确示例：只更新变化的部分
  function rightWay() {
    // 只更新list中的第10项
    const key = `list[10]`;
    this.setData({
      [key]: { updated: true, value: "new value" },
    });
  }

  // 3. 避免频繁setData
  // 使用节流或防抖技术限制高频setData
  // 节流函数示例
  function throttle(fn, delay = 200) {
    let timer = null;
    return function (...args) {
      if (timer) return;
      timer = setTimeout(() => {
        fn.apply(this, args);
        timer = null;
      }, delay);
    };
  }

  // 在页面中使用节流处理高频更新
  Page({
    data: { scrollTop: 0 },
    onLoad() {
      this.setScrollTop = throttle(this.setScrollTop.bind(this), 200);
    },
    // 高频滚动事件处理
    onPageScroll(e) {
      this.setScrollTop(e.scrollTop);
    },
    setScrollTop(top) {
      this.setData({ scrollTop: top });
    },
  });

  // 4. 数据diff
  // 在setData前比较新旧数据，只更新变化部分
  function updateWithDiff(newData) {
    const oldData = this.data.items;
    const diffData = {};

    newData.forEach((item, index) => {
      if (JSON.stringify(item) !== JSON.stringify(oldData[index])) {
        const key = `items[${index}]`;
        diffData[key] = item;
      }
    });

    // 只有有差异才调用setData
    if (Object.keys(diffData).length > 0) {
      this.setData(diffData);
    }
  }
}
```

### 页面结构优化

```javascript
function optimizePageStructure() {
  // 1. 使用惰性渲染（懒加载）
  // WXML中使用wx:if延迟加载不可见区域
  // <view wx:if="{{showSection}}">复杂内容</view>

  // 2. 长列表性能优化
  // 使用虚拟列表，只渲染可视区域内的数据
  Page({
    data: {
      list: [], // 完整数据列表
      visibleList: [], // 可视区域列表
      startIndex: 0, // 起始索引
      endIndex: 20, // 结束索引
    },
    onPageScroll(e) {
      // 根据滚动位置计算可视区域
      const { startIndex, endIndex } = this.calculateVisibleRange(e.scrollTop);
      
      // 更新可视区域数据
      if (
        startIndex !== this.data.startIndex ||
        endIndex !== this.data.endIndex
      ) {
        this.setData({
          startIndex,
          endIndex,
          visibleList: this.data.list.slice(startIndex, endIndex),
        });
      }
    },
    
    // 长列表优化2: 使用自定义组件
    // 将大列表拆分成多个自定义组件，减少单次渲染压力
    onListScroll(e) {
      // 列表滚动逻辑处理
    }

    // 3. 按需加载，分批渲染
    // 初始只渲染必要内容，滚动时加载更多
    calculateVisibleRange(scrollTop) {
      // 假设每项高度为60px
      const itemHeight = 60;
      // 可见区域高度
      const screenHeight = wx.getSystemInfoSync().windowHeight;
      
      // 计算可见区域中第一个和最后一个item的索引
      let startIndex = Math.floor(scrollTop / itemHeight);
      let endIndex = Math.ceil((scrollTop + screenHeight) / itemHeight);
      
      // 上下额外渲染几个item作为缓冲，提高滚动体验
      startIndex = Math.max(0, startIndex - 5);
      endIndex = Math.min(this.data.list.length, endIndex + 5);
      
      return { startIndex, endIndex };
    }
  });
  
  // 4. 使用wx:key提高列表渲染性能
  // <view wx:for="{{list}}" wx:key="unique"> 避免全量更新列表

  // 5. 避免不必要的复杂计算
  Page({
    onLoad() {
      // 错误示例：频繁计算
      this.setData({
        processedItems: this.processItems(this.data.items)
      });
    },
    
    // 优化：缓存计算结果或使用computed属性模式
    processItems(items) {
      // 复杂的数据处理逻辑
      return items.map(item => {
        // 昂贵的计算...
        return { ...item, computed: item.value * 2 };
      });
    }
  });
}
```

### 减少页面重排重绘

```javascript
function reduceReflow() {
  // 1. 批量DOM操作
  // 错误示例：频繁变更引发多次重排
  function wrongWay() {
    this.setData({ width: '100px' });
    this.setData({ height: '100px' });
    this.setData({ margin: '10px' });
    // 每次setData都可能触发重排
  }
  
  // 正确示例：合并变更一次重排
  function rightWay() {
    this.setData({
      width: '100px',
      height: '100px',
      margin: '10px'
    });
    // 只触发一次重排
  }
  
  // 2. 减少样式计算的复杂度
  // - 避免使用复杂的选择器
  // - 降低CSS规则的复杂性
  // - 避免使用引发重排的CSS属性（如box-shadow）
  
  // 3. 利用transform代替位置变更
  // 使用transform不会触发完整的重排
  // 错误示例：
  // <view style="margin-left: {{leftMargin}}px">
  
  // 正确示例：
  // <view style="transform: translateX({{translateX}}px)">
  
  // 4. 先隐藏元素，再操作，最后显示
  // 元素隐藏状态下的修改不会立即触发重排
  // this.setData({ hidden: true });
  // ... 多次修改元素 ...
  // this.setData({ hidden: false });
}
```

## 3. 网络请求优化

网络请求优化：减少请求数量，提高请求效率

```javascript
function optimizeRequests() {
  // 1. 避免重复请求
  // 错误示例：无管理的重复请求
  function wrongWay() {
    // 用户连续多次点击会发出多个相同请求
    wx.request({
      url: 'api/getData',
      // ...
    });
  }
  
  // 正确示例：使用请求锁或队列
  function rightWay() {
    if (this.isRequesting) return; // 请求锁
    
    this.isRequesting = true;
    wx.request({
      url: 'api/getData',
      // ...
      success(res) {
        // 处理结果
      },
      complete: () => {
        this.isRequesting = false; // 解锁
      }
    });
  }
  
  // 2. 并行请求
  function parallelRequests() {
    // 使用Promise.all并行发起多个请求
    Promise.all([
      new Promise(resolve => {
        wx.request({
          url: 'api/getData1',
          success: res => resolve(res.data),
          fail: () => resolve(null)
        });
      }),
      new Promise(resolve => {
        wx.request({
          url: 'api/getData2',
          success: res => resolve(res.data),
          fail: () => resolve(null)
        });
      })
    ]).then(([data1, data2]) => {
      // 同时处理所有结果
    });
  }
  
  // 3. 预请求技术
  // 提前请求可能需要的数据
  Page({
    onLoad() {
      // 加载当前必要数据
      this.loadCurrentPageData();
      
      // 预加载可能跳转页面的数据
      this.preloadNextPageData();
    },
    
    // 预加载下一页数据
    preloadNextPageData() {
      wx.request({
        url: 'api/getNextPageData',
        success: res => {
          // 缓存数据，不立即使用
          this.nextPageData = res.data;
        }
      });
    },
    
    // 点击跳转时直接使用预加载的数据
    onTapItem() {
      // 将预加载的数据通过页面参数传递
      wx.navigateTo({
        url: `/pages/detail/index?preloaded=true`,
        success: res => {
          // 通过eventChannel传递复杂数据
          res.eventChannel.emit('preloadedData', this.nextPageData);
        }
      });
    }
  });
}
```

### 缓存策略

```javascript
function cacheStrategy() {
  // 1. 内存缓存 + 本地存储缓存
  // 高效的内存-存储双层缓存系统
  
  function getCachedData(key, fetchFunc) {
    // 应用内存缓存 (当次启动有效)
    const app = getApp();
    if (!app.cache) app.cache = {};
    
    // 1. 优先使用内存缓存 (最快)
    if (app.cache[key]) {
      // 检查内存缓存是否过期
      if (app.cache[key].expireTime > Date.now()) {
        return Promise.resolve(app.cache[key].data);
      }
    }
    
    // 2. 其次使用本地存储缓存
    return getPersistedData(key).then(data => {
      if (data) return data;
      
      // 3. 最后从网络获取
      return fetchFunc().then(freshData => {
        // 同时更新内存缓存和持久化缓存
        persistData(key, freshData);
        app.cache[key] = {
          data: freshData,
          expireTime: Date.now() + 5 * 60 * 1000 // 5分钟有效期
        };
        return freshData;
      });
    });
  }
  
  // 使用示例
  function getUserInfo() {
    return getCachedData('userInfo', () => {
      // 这个函数只有在缓存未命中时才会执行
      return new Promise(resolve => {
        wx.request({
          url: 'api/getUserInfo',
          success: res => resolve(res.data),
          fail: () => resolve(null)
        });
      });
    });
  }
  
  // 持久化数据到本地存储
  function persistData(key, data, expireTime = 5 * 60 * 1000) {
    wx.setStorage({
      key: `cache_${key}`,
      data: {
        data,
        expireTime: Date.now() + expireTime
      }
    });
  }
  
  // 从本地存储获取数据
  function getPersistedData(key) {
    return new Promise(resolve => {
      wx.getStorage({
        key: `cache_${key}`,
        success(res) {
          // 检查是否过期
          if (res.data && res.data.expireTime > Date.now()) {
            resolve(res.data.data);
          } else {
            // 已过期，删除旧数据
            wx.removeStorage({ key: `cache_${key}` });
            resolve(null);
          }
        },
        fail() {
          resolve(null);
        }
      });
    });
  }
  
  // 2. API请求缓存
  // 为API请求增加缓存层
  const requestCache = {
    cacheApiResponse(url, data, expireTime = 5 * 60 * 1000) {
      // 缓存API响应
      const cacheKey = `api_${url}`;
      persistData(cacheKey, data, expireTime);
    },
    
    getCachedResponse(url) {
      // 获取API缓存
      return getPersistedData(`api_${url}`);
    },
    
    requestWithCache(options, expireTime) {
      const cacheKey = `api_${options.url}`;
      
      return getPersistedData(cacheKey).then(cachedData => {
        if (cachedData) {
          // 返回缓存数据
          return cachedData;
        }
        
        // 发起实际请求
        return new Promise((resolve, reject) => {
          wx.request({
            ...options,
            success: res => {
              // 缓存响应
              this.cacheApiResponse(options.url, res.data, expireTime);
              resolve(res.data);
            },
            fail: reject
          });
        });
      });
    }
  };
}
```

### 请求优化

```javascript
function requestOptimization() {
  // 1. 数据压缩
  // - 服务器返回gzip压缩数据
  // - 请求时减少不必要字段
  // - 使用简洁的数据结构
  
  // 2. 请求合并
  // 将多个请求合并为一个批量请求，减少请求次数
  
  // 3. 请求重试机制
  function requestWithRetry(options, retryCount = 3, delay = 1000) {
    return new Promise((resolve, reject) => {
      function attempt(attemptsLeft) {
        wx.request({
          ...options,
          success: resolve,
          fail: (error) => {
            if (attemptsLeft <= 1) {
              // 没有重试次数了，最终失败
              reject(error);
              return;
            }
            
            // 线性退避或指数退避延迟
            setTimeout(() => {
              attempt(attemptsLeft - 1);
            }, delay);
          }
        });
      }
      
      attempt(retryCount);
    });
  }
  
  // 4. 网络状态感知
  function watchNetworkStatus() {
    // 监听网络状态
    wx.onNetworkStatusChange(res => {
      const { isConnected, networkType } = res;
      
      if (!isConnected) {
        // 网络断开，暂停请求，使用缓存数据
        this.setData({ offline: true });
      } else {
        // 网络恢复，恢复请求队列
        this.setData({ offline: false });
        
        if (networkType === '2g' || networkType === '3g') {
          // 弱网络模式，调整请求策略
          this.setData({ weakNetwork: true });
          // 弱网模式下：
          // - 减少请求频率
          // - 延长缓存时间
          // - 降低图片质量
        } else {
          this.setData({ weakNetwork: false });
        }
      }
    });
    
    // 初始检查网络状态
    wx.getNetworkType({
      success: res => {
        const { networkType } = res;
        this.setData({
          offline: networkType === 'none',
          weakNetwork: networkType === '2g' || networkType === '3g'
        });
      }
    });
  }
}
```

## 4. 内存优化

内存优化：避免内存泄漏，控制内存占用

```javascript
function releaseResources() {
  // 1. 页面卸载时释放资源
  Page({
    timers: [],
    
    onLoad() {
      // 创建定时器
      this.timers.push(setInterval(() => {
        // 执行某些操作
      }, 1000));
    },
    
    onUnload() {
      // 清理所有定时器
      this.timers.forEach(timer => clearInterval(timer));
      this.timers = [];
      
      // 清理全局缓存中的临时数据
      const app = getApp();
      if (app.cache && app.cache.tempData) {
        delete app.cache.tempData;
      }
      
      // 清理大型对象引用
      this.largeData = null;
      
      // 解绑事件监听
      wx.offNetworkStatusChange();
      // 其他事件解绑...
    }
  });
  
  // 2. 避免闭包陷阱
  // 错误示例：造成内存泄漏的闭包
  function wrongWay() {
    let bigData = new Array(10000).fill('x');
    
    function startInterval() {
      // bigData被闭包引用，无法释放
      setInterval(() => {
        console.log(bigData.length);
      }, 5000);
    }
    
    startInterval();
    // 即使函数结束，bigData也无法被GC回收
  }
  
  // 正确示例：控制闭包引用
  function rightWay() {
    let bigData = new Array(10000).fill('x');
    
    function startInterval() {
      // 只引用需要的数据
      const dataLength = bigData.length;
      
      setInterval(() => {
        console.log(dataLength);
      }, 5000);
      
      // 释放对原始大数据的引用
      bigData = null;
    }
    
    startInterval();
    // bigData可以被GC回收
  }
  
  // 3. 大对象重用
  // 处理大型列表时，尽量复用对象
  function saveBigList(list) {
    // 错误：每次创建新的数组和对象
    // this.setData({ list: list.map(item => ({ ...item, extra: 'data' })) });
    
    // 正确：复用已存在的对象，只改变必要的属性
    this.data.list.forEach((oldItem, i) => {
      Object.assign(oldItem, list[i]);
    });
    this.setData({ list: this.data.list });
  }
  
  // 4. 图片资源优化
  function loadImage() {
    // 1. 使用统一尺寸的图片，避免图片缩放
    // 2. 及时释放临时图片
    wx.chooseImage({
      success: (res) => {
        const tempFilePaths = res.tempFilePaths;
        
        // 上传完后释放临时文件
        this.uploadFile(tempFilePaths[0]).then(() => {
          // 小程序SDK会自动清理，但主动调用可加快释放
          // 注意：此API已不推荐使用，但思路值得借鉴
          // wx.removeSavedFile({
          //   filePath: tempFilePaths[0]
          // });
        });
      }
    });
  }
}
```

### 防止内存泄漏

```javascript
function preventMemoryLeaks() {
  // 1. 及时销毁不再使用的对象
  // 2. 避免全局变量累积
  
  // 3. 使用弱引用处理大对象
  function processObject(obj) {
    // 使用WeakMap存储额外数据，不阻止垃圾回收
    const extraData = new WeakMap();
    
    extraData.set(obj, { timestamp: Date.now(), extra: 'metadata' });
    
    // 处理完成后，不需要明确清理
    // 如果obj被其他地方释放，WeakMap中的数据会自动被GC回收
    return obj;
  }
  
  // 4. 使用缓存大小限制
  // 实现简单的LRU缓存
  class LRUCache {
    constructor(limit = 10) {
      this.limit = limit;
      this.cache = new Map();
      this.keys = [];
    }
    
    get(key) {
      if (!this.cache.has(key)) return undefined;
      
      // 更新使用记录，移到队尾
      const idx = this.keys.indexOf(key);
      this.keys.splice(idx, 1);
      this.keys.push(key);
      
      return this.cache.get(key);
    }
    
    set(key, value) {
      // 如果key已存在，更新value和位置
      if (this.cache.has(key)) {
        this.cache.set(key, value);
        
        // 更新使用顺序
        const idx = this.keys.indexOf(key);
        this.keys.splice(idx, 1);
        this.keys.push(key);
        return;
      }
      
      // 如果缓存满了，删除最久未使用的项
      if (this.keys.length >= this.limit) {
        const oldestKey = this.keys.shift();
        this.cache.delete(oldestKey);
      }
      
      // 添加新项
      this.cache.set(key, value);
      this.keys.push(key);
    }
    
    clear() {
      this.cache.clear();
      this.keys = [];
    }
  }
  
  // 使用LRU缓存限制页面内存增长
  const imageCache = new LRUCache(20); // 最多缓存20张图片
  
  // 在长列表中使用缓存优化
  Page({
    // 加载更多数据时使用缓存
    loadNextPage() {
      wx.request({
        url: `api/list?page=${this.data.nextPage}`,
        success: res => {
          // 处理图片缓存
          res.data.forEach(item => {
            // 将图片缓存到LRU中，限制内存使用
            if (item.imageUrl && !imageCache.get(item.imageUrl)) {
              wx.getImageInfo({
                src: item.imageUrl,
                success: imgRes => {
                  // 缓存图片信息，而不是图片本身
                  imageCache.set(item.imageUrl, {
                    width: imgRes.width,
                    height: imgRes.height,
                    path: imgRes.path
                  });
                }
              });
            }
          });
          
          // 更新列表数据
          this.setData({
            list: [...this.data.list, ...res.data],
            nextPage: this.data.nextPage + 1
          });
        }
      });
    }
  });
}
```

### 减少内存占用

```javascript
function reduceMemoryUsage() {
  // 1. 避免数据冗余
  // - 移除重复数据
  // - 使用ID引用而非复制整个对象
  
  // 2. 分页加载和释放
  // - 释放已经离开视图的数据
  // - 只保留必要的可视区域数据
  
  // 3. 使用更高效的数据结构
  // - 使用TypedArray替代普通数组存储大量数值
  // - 使用Map和Set优化查找和去重操作
  // - 使用ArrayBuffer处理二进制数据
  
  // 4. 避免过度使用闭包和高阶函数
  // 每个函数都会带来内存开销，频繁创建临时函数会增加GC压力
  
  // 5. 延迟加载大型资源
  // - 在用户操作触发后才加载大型资源
  // - 避免在初始化阶段加载所有资源
  
  // 6. 对象池技术
  // 对于频繁创建和销毁的对象，使用对象池模式
  const objectPool = {
    pool: [],
    maxSize: 20,
    
    // 从池中获取对象
    get() {
      if (this.pool.length > 0) {
        return this.pool.pop();
      } else {
        // 没有可用对象，创建新的
        return this.createNewObject();
      }
    },
    
    // 回收对象到池中
    recycle(obj) {
      // 重置对象状态
      this.resetObject(obj);
      
      // 如果池还没满，则放回池中重用
      if (this.pool.length < this.maxSize) {
        this.pool.push(obj);
      }
      // 否则让它被GC回收
    },
    
    // 创建新对象
    createNewObject() {
      return { /* 新对象属性 */ };
    },
    
    // 重置对象到初始状态
    resetObject(obj) {
      // 清除所有属性
      for (let key in obj) {
        if (typeof obj[key] !== 'function') {
          obj[key] = null;
        }
      }
    }
  };
  
  // 使用对象池示例
  function getHeavyObject() {
    // 从池中获取对象
    const obj = objectPool.get();
    
    // 配置对象
    obj.id = generateId();
    obj.data = loadData();
    
    return obj;
  }
  
  // 完成使用后回收对象
  function recycleObject(obj) {
    objectPool.recycle(obj);
  }
}
```

## 5. 常见面试题

1. 如何优化小程序的启动性能?
2. setData的性能优化有哪些方法?
3. 小程序长列表性能优化的思路?
4. 如何处理小程序的内存泄漏问题?
5. 小程序请求优化和缓存策略怎么做?
6. 小程序页面切换时如何减少闪烁和卡顿?
7. 主包瘦身有哪些具体方法?
8. 如何分析和定位小程序性能问题?
9. 如何使用分包提升性能?
10. 小程序什么情况下会触发重排重绘，如何避免? 